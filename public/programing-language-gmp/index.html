<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>GMP调度模型 - 编程浪子</title><meta name="Description" content="详解golang 的gmp调度模型"><meta property="og:title" content="GMP调度模型" />
<meta property="og:description" content="详解golang 的gmp调度模型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.bardblog.cn/programing-language-gmp/" /><meta property="og:image" content="https://www.bardblog.cn/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-17T08:59:43+08:00" />
<meta property="article:modified_time" content="2023-09-17T08:59:43+08:00" /><meta property="og:site_name" content="编程浪子" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.bardblog.cn/logo.png"/>

<meta name="twitter:title" content="GMP调度模型"/>
<meta name="twitter:description" content="详解golang 的gmp调度模型"/>
<meta name="application-name" content="Bard">
<meta name="apple-mobile-web-app-title" content="Bard"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.bardblog.cn/programing-language-gmp/" /><link rel="prev" href="https://www.bardblog.cn/algorithm-cache-obsolescence/" /><link rel="next" href="https://www.bardblog.cn/algorithm-greedy-disjoint/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "GMP调度模型",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.bardblog.cn\/programing-language-gmp\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/www.bardblog.cn\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "Go, GMP, Gorotinue, Thread","wordcount":  7122 ,
        "url": "https:\/\/www.bardblog.cn\/programing-language-gmp\/","datePublished": "2023-09-17T08:59:43+08:00","dateModified": "2023-09-17T08:59:43+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": {
                    "@type": "ImageObject",
                    "url": "https:\/\/www.bardblog.cn\/images\/avatar.gif",
                    "width":  700 ,
                    "height":  700 
                }},"author": {
                "@type": "Person",
                "name": "Bard"
            },"description": "详解golang 的gmp调度模型"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="编程浪子"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/YourFantasy/blog" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/programing-language-gmp/" selected>简体中文</option><option value="/en/programing-language-gmp/">English</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="编程浪子"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/YourFantasy/blog" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/programing-language-gmp/" selected>简体中文</option><option value="/en/programing-language-gmp/">English</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">GMP调度模型</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="www.bardblog.cn" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Bard</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/technology/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>technology</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-09-17">2023-09-17</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 7122 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#进程线程协程">进程线程协程</a></li>
    <li><a href="#gmp调度机制">GMP调度机制</a>
      <ul>
        <li><a href="#g">G</a></li>
        <li><a href="#m">M</a></li>
        <li><a href="#p">P</a></li>
        <li><a href="#schedt">Schedt</a></li>
      </ul>
    </li>
    <li><a href="#调度过程">调度过程</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="进程线程协程">进程线程协程</h2>
<p>无论程序使用何种编程语言编写，它们最终都在操作系统中运行。运行中的程序被视为进程，每个进程拥有独立的内存空间和资源，且进程之间相互隔离。通常，应用程序具有多种功能，例如聊天应用在进行语音通话时还可以进行文字聊天。支撑这些功能运行的并非进程，而是线程。线程属于进程，一个进程可以拥有多个线程，它们并发执行以支持进程的多个功能。进程和线程作为操作系统的基本单位或资源，多线程技术充分利用现代CPU的多核资源，提高任务执行效率。</p>
<p>尽管进程-线程两级结构被广泛应用于软件开发，线程并非足够轻量。线程在完成任务的同时，还需承担额外开销，如线程切换。当线程因I/O或锁等原因阻塞时，会发生线程切换。然而，切换过程耗时较长，导致CPU资源得不到充分利用。因此，需要更轻量级的执行单元以提高切换效率，从而充分利用CPU资源。Go语言通过实现协程（goroutine）和调度机制，为开发者提供了更轻量级的执行单元。与线程相比，协程保存的上下文内容更少，切换速度更快，从而高效利用系统资源，提高并发度。</p>
<p>协程是用户级线程，由Go运行时（runtime）管理和调度，而非直接由操作系统管理。这使得Go运行时能在较少的操作系统线程上调度大量协程，降低线程切换开销。当协程因I/O或其他原因阻塞时，Go运行时将其他协程调度到同一操作系统线程上运行，实现高效并发执行。</p>
<p>Go语言的协程模型简化了高并发程序编写。使用关键字go，开发者轻松创建新协程并发执行函数。Go语言还提供强大的并发原语，如通道（channel）和同步原语（如互斥锁和WaitGroup），帮助开发者在协程间进行安全的数据传递和同步。</p>
<h2 id="gmp调度机制">GMP调度机制</h2>
<p>Go语言实现了一套高效的调度机制，在运行时管理和调度goroutine，而不是让操作系统直接管理。这种机制类似于“虚拟线程”的概念，Go在语言层面模拟了操作系统线程切换机制。</p>
<p>在传统的进程-线程二级结构中，一个线程隶属于某个固定的进程，一个进程可以拥有多个线程，形成1:M的模型。然而，在Go语言的GMP模型中，协程（G）和线程（M）之间形成了一个M:N的模型。这意味着一个协程并不是固定承载在一个线程上，而是可以在多个线程之间切换和轮转执行。这种模型允许更加高效地利用系统资源，提高并发性能。</p>
<p>GMP模型中的三个主要组件分别是：G（goroutine，协程）、M（machine，线程）和P（processor，处理器，不是指的cpu）。G表示协程，M表示操作系统线程，P表示Go运行时的调度器。在这个模型中，P负责将G调度到M上执行。一个P可以管理多个G，一个M可以关联到一个P。这种M:N的关系使得Go运行时可以在较少的操作系统线程上调度大量的协程，降低了线程切换的开销。
<figure><a class="lightgallery" href="/programing-language-gmp/gmp.png" title="GMP" data-thumbnail="/programing-language-gmp/gmp.png" data-sub-html="<h2>GMP调度机制</h2><p>GMP</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/programing-language-gmp/gmp.png"
            data-srcset="/programing-language-gmp/gmp.png, /programing-language-gmp/gmp.png 1.5x, /programing-language-gmp/gmp.png 2x"
            data-sizes="auto"
            alt="/programing-language-gmp/gmp.png" width="4578" height="3099" />
    </a><figcaption class="image-caption">GMP调度机制</figcaption>
    </figure></p>
<h3 id="g">G</h3>
<p>G就是我们常说的goroutinue，G的本体是个结构体，保存着协程的上下文、状态、协程栈等信息，对应着<code>src/runtime/runtime2.go:414</code>的g结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Stack parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// innermost panic - offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_defer</span>    <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// innermost defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">m</span>         <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sched</span>     <span class="nx">gobuf</span>
</span></span><span class="line"><span class="cl">	<span class="nx">syscallsp</span> <span class="kt">uintptr</span> <span class="c1">// if status==Gsyscall, syscallsp = sched.sp to use during gc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">syscallpc</span> <span class="kt">uintptr</span> <span class="c1">// if status==Gsyscall, syscallpc = sched.pc to use during gc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stktopsp</span>  <span class="kt">uintptr</span> <span class="c1">// expected sp at top of stack, to check in traceback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// param is a generic pointer parameter field used to pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// values in particular contexts where other storage for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// parameter would be difficult to find. It is currently used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// in three ways:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 1. When a channel operation wakes up a blocked goroutine, it sets param to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    point to the sudog of the completed blocking operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    stack may have moved in the meantime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    closure in the runtime is forbidden.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">param</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomicstatus</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stackLock</span>    <span class="kt">uint32</span> <span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">goid</span>         <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">schedlink</span>    <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">waitsince</span>    <span class="kt">int64</span>      <span class="c1">// approx time when the g become blocked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">waitreason</span>   <span class="nx">waitReason</span> <span class="c1">// if status==Gwaiting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">preempt</span>       <span class="kt">bool</span> <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">preemptStop</span>   <span class="kt">bool</span> <span class="c1">// transition to _Gpreempted on preemption; otherwise, just deschedule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">preemptShrink</span> <span class="kt">bool</span> <span class="c1">// shrink stack at synchronous safe point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// asyncSafePoint is set if g is stopped at an asynchronous
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// safe point. This means there are frames on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// without precise pointer information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">asyncSafePoint</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">paniconfault</span> <span class="kt">bool</span> <span class="c1">// panic (instead of crash) on unexpected fault address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcscandone</span>   <span class="kt">bool</span> <span class="c1">// g has scanned stack; protected by _Gscan bit in status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">throwsplit</span>   <span class="kt">bool</span> <span class="c1">// must not split stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// activeStackChans indicates that there are unlocked channels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pointing into this goroutine&#39;s stack. If true, stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// copying needs to acquire channel locks to protect these
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// areas of the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">activeStackChans</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// parkingOnChan indicates that the goroutine is about to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// park on a chansend or chanrecv. Used to signal an unsafe point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// for stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">parkingOnChan</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">raceignore</span>    <span class="kt">int8</span>  <span class="c1">// ignore race detection events
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tracking</span>      <span class="kt">bool</span>  <span class="c1">// whether we&#39;re tracking this G for sched latency statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">trackingSeq</span>   <span class="kt">uint8</span> <span class="c1">// used to decide whether to track this G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">trackingStamp</span> <span class="kt">int64</span> <span class="c1">// timestamp of when the G last started being tracked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runnableTime</span>  <span class="kt">int64</span> <span class="c1">// the amount of time spent runnable, cleared when running, only used when tracking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lockedm</span>       <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sig</span>           <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">writebuf</span>      <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sigcode0</span>      <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sigcode1</span>      <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sigpc</span>         <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">parentGoid</span>    <span class="kt">uint64</span>          <span class="c1">// goid of goroutine that created this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gopc</span>          <span class="kt">uintptr</span>         <span class="c1">// pc of go statement that created this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ancestors</span>     <span class="o">*</span><span class="p">[]</span><span class="nx">ancestorInfo</span> <span class="c1">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">startpc</span>       <span class="kt">uintptr</span>         <span class="c1">// pc of goroutine function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">racectx</span>       <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">waiting</span>       <span class="o">*</span><span class="nx">sudog</span>         <span class="c1">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cgoCtxt</span>       <span class="p">[]</span><span class="kt">uintptr</span>      <span class="c1">// cgo traceback context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">labels</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// profiler labels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timer</span>         <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// cached timer for time.Sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">selectDone</span>    <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span>  <span class="c1">// are we participating in a select and did someone win the race?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// goroutineProfiled indicates the status of this goroutine&#39;s stack for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// current in-progress goroutine profile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">goroutineProfiled</span> <span class="nx">goroutineProfileStateHolder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Per-G tracer state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">trace</span> <span class="nx">gTraceState</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Per-G GC state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// gcAssistBytes is this G&#39;s GC assist credit in terms of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// bytes allocated. If this is positive, then the G has credit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to allocate gcAssistBytes bytes without assisting. If this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// is negative, then the G must correct this by performing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// scan work. We track this in bytes to make it fast to update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and check for debt in the malloc hot path. The assist ratio
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// determines how this corresponds to scan work debt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcAssistBytes</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以将G（goroutine）理解为一个变量，它保存了当前协程的相关信息，包括栈信息、状态信息、defer、panic以及当前挂靠的线程信息等。协程可以粗略地看作一段正在运行或将要运行的函数。实际上，代码逻辑并不能直接在G上运行，而是由线程从队列中取出G并执行。G可以看作一个任务（task），保存着代码运行的上下文。</p>
<p>这个任务很多时候不是一次性执行完的，而是被多个线程接力执行多次，才能完成。换句话说，协程切换的频率相比于线程要高得多。但是由于协程占用的资源更少，切换过程也更迅速，因此在上下文切换上耗费的时间比例更低。这使得用于执行任务的时间更多，从而提高了CPU的有效利用率。</p>
<h3 id="m">M</h3>
<p>M（machine）对应于操作系统的一个线程，负责从队列中取出一个G（goroutine）进行执行。在同一时刻，一个M只能运行一个G。与传统模式不同，上下文切换由G完成而非M。M作为真正执行代码的实体，在执行完G的全部或部分任务后，会更新G的状态，并将其重新放入工作队列中，然后继续取出其他G执行。</p>
<p>假设我的机器是4核，我没有做额外的设置，M的数量就是4，在go程序进程启动的时候，会调用操作系统的APi创建4个线程分配给进程的runtime，这四个线程在程序运行过程中会被重复利用，而不会被回收，即使当前Go程序最多只有3个协程。这种机制有助于减少线程创建和销毁的开销，提高系统的并发性能。
假设四个线程的ID分别是1001、1002、1003和1004，它们在程序运行过程中是固定的。如果Go程序进程有50万个协程，协程切换非常迅速，那么这四个线程就像一个“永动机”，不停地执行这50万个G（goroutine）。</p>
<p>相比于传统的进程-线程模型，这种机制使得线程能够做更多的“功”，因为线程本身不需要进行上下文切换，而只是不停地取任务执行任务。上下文切换的工作交给了G（协程）来完成。这种灵活的调度机制使得Go能够更高效地利用系统资源，提高并发性能。</p>
<p>Goroutinue类似于空间换时间的策略，主要体现在两点，一是预先创建线程：Go运行时会根据CPU核心数预先创建一定数量的线程（M），虽然这可能导致某些线程闲置，从而造成资源浪费，但这种策略可以减少线程创建和销毁的开销，从而提高系统的并发性能；二是协程资源开销：相比于传统的进程-线程模型，协程本身也会占用一定的系统资源。虽然单个协程非常轻量，但是大量的协程仍会增加系统的开销。此外，如果协程被泄露，可能会导致系统资源得不到回收，从而可能引发内存溢出（OOM）。</p>
<h3 id="p">P</h3>
<p>在Go运行时中，P（Processor）处理器充当G（goroutine）和M（machine）之间的桥梁。需要注意的是，P并不是指CPU，而是一个结构体变量（<code>src/runtime/runtime2.go:621</code>），负责管理和调度G与M之间的关系。</p>
<p>M从队列中取G执行。这个队列实际上是属于P的。每个P都有一个本地队列，用于存储待执行的G。此外，还有一个全局队列，用于存储所有P的本地队列无法容纳的G。当使用<code>go</code>关键字创建一个协程时，该协程并不一定会立即执行，而是会被放入某个P的本地队列中。P的本地队列是一个长度为256的数组。如果协程数量过多，以至于所有P的本地队列都已满，那么新创建的协程将被放入全局队列中。全局队列类似于一个双链表，理论上长度是无限的。</p>
<p>通过这种机制，Go运行时可以灵活地调度大量协程在有限的线程上执行，从而实现高效的并发执行。P作为G和M之间的中介，确保了协程能够在不同的线程之间切换，充分利用系统资源。这种设计使得Go语言能够在高并发场景下表现出卓越的性能，同时简化了并发编程的复杂性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">id</span>          <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">link</span>        <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">	<span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pcache</span>      <span class="nx">pageCache</span>
</span></span><span class="line"><span class="cl">	<span class="nx">raceprocctx</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">deferpool</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs (see panic.go)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">goidcache</span>    <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">goidcacheend</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runqhead</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runqtail</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the current G and should be run next instead of what&#39;s in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// slice. It will inherit the time left in the current time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// slice. If a set of goroutines is locked in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// unit and eliminates the (potentially large) scheduling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// goroutines to the end of the run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Note that while other P&#39;s may atomically CAS this to zero,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// only the owner P can CAS it to a valid G.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runnext</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Available G&#39;s (status == Gdead)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gList</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Cache of mspan objects from the heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mspancache</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We need an explicit length here because this field is used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// in allocation codepaths where write barriers are not allowed,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// and eliminating the write barrier/keeping it eliminated from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// slice updates is tricky, more so than just managing the length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// ourselves.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">		<span class="nx">buf</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Cache of a single pinner object to reduce allocations from repeated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pinner creation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pinnerCache</span> <span class="o">*</span><span class="nx">pinner</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">trace</span> <span class="nx">pTraceState</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// The when field of the first entry on the timer heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This is 0 if the timer heap is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timer0When</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// The earliest known nextwhen field of a timer with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// timerModifiedEarlier status. Because the timer may have been
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// modified again, there need not be any timer with this value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This is 0 if there are no timerModifiedEarlier timers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timerModifiedEarliest</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Per-P GC state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcAssistTime</span>         <span class="kt">int64</span> <span class="c1">// Nanoseconds in assistAlloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span> <span class="c1">// Nanoseconds in fractional mark worker (atomic)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// limiterEvent tracks events for the GC CPU limiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">limiterEvent</span> <span class="nx">limiterEvent</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// gcMarkWorkerMode is the mode for the next mark worker to run in.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// That is, this is used to communicate with the worker goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// selected for immediate execution by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// gcController.findRunnableGCWorker. When scheduling other goroutines,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// this field must be set to gcMarkWorkerNotWorker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcMarkWorkerMode</span> <span class="nx">gcMarkWorkerMode</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// gcMarkWorkerStartTime is the nanotime() at which the most recent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// mark worker started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// filled by write barriers, drained by mutator assists, and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// disposed on certain GC state transitions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcw</span> <span class="nx">gcWork</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// wbBuf is this P&#39;s GC write barrier buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO: Consider caching this in the running G.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wbBuf</span> <span class="nx">wbBuf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">runSafePointFn</span> <span class="kt">uint32</span> <span class="c1">// if 1, run sched.safePointFn at next safe point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// statsSeq is a counter indicating whether this P is currently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// writing any stats. Its value is even when not, odd when it is.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">statsSeq</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Lock for timers. We normally access the timers while running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on this P, but the scheduler can also do it from a different P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timersLock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Actions to take at some time. This is used to implement the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// standard library&#39;s time package.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Must hold timersLock to access.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Number of timers in P&#39;s heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">numTimers</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Number of timerDeleted timers in P&#39;s heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">deletedTimers</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Race context used while executing timer functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timerRaceCtx</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// maxStackScanDelta accumulates the amount of stack space held by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// live goroutines (i.e. those eligible for stack scanning).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Flushed to gcController.maxStackScan once maxStackScanSlack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// or -maxStackScanSlack is reached.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxStackScanDelta</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// gc-time statistics about current goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Note that this differs from maxStackScan in that this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// accumulates the actual stack observed to be used at GC time (hi - sp),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// not an instantaneous measure of the total stack size that might need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to be scanned (hi - lo).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">scannedStackSize</span> <span class="kt">uint64</span> <span class="c1">// stack size of goroutines scanned by this P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">scannedStacks</span>    <span class="kt">uint64</span> <span class="c1">// number of goroutines scanned by this P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// preempt is set to indicate that this P should be enter the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// scheduler ASAP (regardless of what G is running on it).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">preempt</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// pageTraceBuf is a buffer for writing out page allocation/free/scavenge traces.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Used only if GOEXPERIMENT=pagetrace.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pageTraceBuf</span> <span class="nx">pageTraceBuf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Padding is no longer needed. False sharing is now not a worry because p is large enough
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// that its size class is an integer multiple of the cache line size (for any of our architectures).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="schedt">Schedt</h3>
<p>上面我们讨论了GMP模型中G（goroutine）、M（machine）和P（Processor）各自的概念和作用。然而，我们还需要一个调度器来完成G、M、P之间的整合和协调。在Go运行时中，这个调度器被称为Sched（同样是个结构体，对应着<code>src/runtime/runtime2.go:774</code>），负责完成上述的调度过程。
Sched调度器的主要职责包括：</p>
<ul>
<li>
<p>确定将新创建的协程放入哪个P的本地队列或者全局队列。Sched会根据当前的负载情况和资源分配策略，将新创建的协程分配给合适的P。</p>
</li>
<li>
<p>确定M从哪个P的本地队列中取出G执行。Sched会监控各个P的本地队列，以确保M能够从合适的P中取出G执行。当一个M完成了一个G的执行后，Sched会将该G重新放入工作队列，并指导M继续从其他P的本地队列中取出G执行。上文提到的P的全局队列对应着schedt的<code>runq</code>字段。</p>
</li>
</ul>
<p>通过Sched调度器的协调，Go运行时可以实现G、M、P之间的高效整合，从而在高并发场景下实现卓越的性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">goidgen</span>   <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastpoll</span>  <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span> <span class="c1">// time of last network poll, 0 if currently polling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pollUntil</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span> <span class="c1">// time to which current poll is sleeping
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// sure to call checkdead().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// number of idle m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// number of locked m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// number of m&#39;s that have been created and next M ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// maximum number of m&#39;s allowed (or die)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// number of system m&#39;s not counted for deadlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// cumulative number of freed m&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">ngsys</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int32</span> <span class="c1">// number of system goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">pidle</span>        <span class="nx">puintptr</span> <span class="c1">// idle p&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">npidle</span>       <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nmspinning</span>   <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int32</span>  <span class="c1">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">needspinning</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span> <span class="c1">// See &#34;Delicate dance&#34; comment in proc.go. Boolean. Must hold sched.lock to set to 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Global runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runq</span>     <span class="nx">gQueue</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runqsize</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// disable controls selective disabling of the scheduler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Use schedEnableUser to control this.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// disable is protected by sched.lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">disable</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// user disables scheduling of user goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">user</span>     <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">		<span class="nx">runnable</span> <span class="nx">gQueue</span> <span class="c1">// pending runnable Gs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n</span>        <span class="kt">int32</span>  <span class="c1">// length of runnable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Global cache of dead G&#39;s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lock</span>    <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Central cache of sudog structs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sudoglock</span>  <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Central pool of available defer structs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">deferlock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">deferpool</span> <span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// m.exited is set. Linked through m.freelink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">gcwaiting</span>  <span class="nx">atomic</span><span class="p">.</span><span class="nx">Bool</span> <span class="c1">// gc is waiting to run
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stopwait</span>   <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stopnote</span>   <span class="nx">note</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sysmonwait</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sysmonnote</span> <span class="nx">note</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// safepointFn should be called on each P at the next GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// safepoint if p.runSafePointFn is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">safePointFn</span>   <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">safePointWait</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">safePointNote</span> <span class="nx">note</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">profilehz</span> <span class="kt">int32</span> <span class="c1">// cpu profiling rate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">procresizetime</span> <span class="kt">int64</span> <span class="c1">// nanotime() of last change to gomaxprocs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">totaltime</span>      <span class="kt">int64</span> <span class="c1">// ∫gomaxprocs dt up to procresizetime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// sysmonlock protects sysmon&#39;s actions on the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Acquire and hold this mutex to block sysmon from interacting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// with the rest of the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sysmonlock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// timeToRun is a distribution of scheduling latencies, defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// as the sum of time a G spends in the _Grunnable state before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// it transitions to _Grunning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timeToRun</span> <span class="nx">timeHistogram</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// idleTime is the total CPU time Ps have &#34;spent&#34; idle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Reset on each GC cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">idleTime</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// totalMutexWaitTime is the sum of time goroutines have spent in _Gwaiting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// with a waitreason of the form waitReasonSync{RW,}Mutex{R,}Lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">totalMutexWaitTime</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="调度过程">调度过程</h2>
<p>在runtime2.go文件中有几个全局变量，分别是allm、gomaxprocs、ncpu、sched、newprocs、allp；下面分别解释一下它们的含义及作用。
在Go运行时中，以下变量和结构体用于管理和调度G（goroutine）、M（machine）和P（Processor）之间的关系：</p>
<ul>
<li>
<p><code>allm</code>：一个指向M（machine）链表头部的指针。所有的M实例被组织成一个链表结构，以便在程序运行过程中方便地添加和删除M实例。</p>
</li>
<li>
<p><code>gomaxprocs</code>：一个整数变量，表示允许同时运行的最大操作系统线程数（即M的数量）。默认情况下，它的值等于系统的CPU核心数。您可以通过设置<code>GOMAXPROCS</code>环境变量或使用<code>runtime.GOMAXPROCS()</code>函数来调整此值。</p>
</li>
<li>
<p><code>ncpu</code>：一个整数变量，表示系统的CPU核心数。它在程序启动时被初始化，并在整个程序运行过程中保持不变。</p>
</li>
<li>
<p><code>sched</code>：一个结构体，表示Go运行时的调度器。它负责协调G、M和P之间的关系，包括将新创建的协程分配给合适的P，以及指导M从合适的P的本地队列中取出G执行。</p>
</li>
<li>
<p><code>newprocs</code>：一个整数变量，用于在调整<code>gomaxprocs</code>值时暂存新的最大并发线程数。当<code>newprocs</code>的值与<code>gomaxprocs</code>不同时，Go运行时会在下一个调度周期中更新<code>gomaxprocs</code>的值。</p>
</li>
<li>
<p><code>allp</code>：一个切片，用于存储所有的P（Processor）实例。在程序运行过程中，P的数量可能会发生变化，例如，当您调整<code>GOMAXPROCS</code>值时。使用切片可以方便地调整P的数量，同时保持对所有P实例的引用。</p>
</li>
</ul>
<p>所有的调度都是由sched变量完成的，在进程启动的时候，会把主线程分配到某个m上，当有新的goroutinue创建的时候会随机分配到p的某个队列上，如果选择的p满了，再选择其它的p，如果都满了则会放到全局队列上。总结一下调度过程：</p>
<ol>
<li>
<p>创建G：当使用<code>go</code>关键字创建一个新的协程时，<code>newproc</code>函数会被调用。在<code>newproc</code>函数中，会创建一个新的G实例，并将其与待执行的函数关联。</p>
</li>
<li>
<p>将G放入队列：Sched调度器会将新创建的G尝试放入与当前正在执行的G关联的P的本地队列。如果当前P的本地队列已满，新创建的G会被放入全局队列。</p>
</li>
<li>
<p>M从队列中取G：Sched调度器会指导M从关联的P的本地队列中取出G执行。如果本地队列为空，M会尝试从全局队列或其他P的本地队列中偷取G。</p>
</li>
<li>
<p>执行G：M会执行取出的G，直到G执行完成或遇到阻塞操作（如I/O操作）。</p>
</li>
<li>
<p>G执行完成：当G执行完成后，Sched调度器会将G标记为已完成。如果G没有其他引用，它会在垃圾回收过程中被回收。与此同时，Sched调度器会指导M继续从关联的P的本地队列中取出下一个G执行。</p>
</li>
<li>
<p>G阻塞：当G遇到阻塞操作时（如IO操作、系统调用、sleep等），Sched调度器会将阻塞的G状态从Grunning切换到Gwaitin状态并放入原先所在的P（Processor）的本地队列或全局队列中，以便在阻塞操作完成后能够继续执行。同时，M会尝试从P的本地队列中取出另一个G执行。在这种情况下，Go运行时可能会创建一个新的M来执行其他G，以保持并发性能。</p>
</li>
<li>
<p>G解除阻塞：当阻塞操作完成后，Sched调度器会将阻塞G状态从Gwaiting状态切换到Grunnable状态，等待再次被调度到M上运行。</p>
</li>
</ol>
<p>在整个调度过程中，Sched调度器负责管理G与P之间的交互，如将G放入P的本地队列以及从P的本地队列中取出G执行。同时，Sched调度器也负责协调P与M之间的交互，如指导M从关联的P的本地队列中取出G执行，以及在G阻塞时将G与M解除关联。</p>
<p>通过Sched调度器和GMP模型的协同工作，Go运行时可以实现高并发性能，同时简化了并发编程的复杂性。</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-09-17</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/programing-language-gmp/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://www.bardblog.cn/programing-language-gmp/" data-title="GMP调度模型" data-via="cz960601" data-hashtags="Go,GMP,Gorotinue,Thread"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://www.bardblog.cn/programing-language-gmp/" data-hashtag="Go"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://www.bardblog.cn/programing-language-gmp/" data-title="GMP调度模型"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://www.bardblog.cn/programing-language-gmp/"><i class="fab fa-reddit fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://www.bardblog.cn/programing-language-gmp/" data-title="GMP调度模型"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://www.bardblog.cn/programing-language-gmp/" data-title="GMP调度模型"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/go/">Go</a>,&nbsp;<a href="/tags/gmp/">GMP</a>,&nbsp;<a href="/tags/gorotinue/">Gorotinue</a>,&nbsp;<a href="/tags/thread/">Thread</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/algorithm-cache-obsolescence/" class="prev" rel="prev" title="LFU和LRU缓存淘汰算法"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>LFU和LRU缓存淘汰算法</a>
            <a href="/algorithm-greedy-disjoint/" class="next" rel="next" title="最大不相交区间数量">最大不相交区间数量<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.118.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2023 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://www.bardblog.cn" target="_blank">Bard</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"gitalk":{"admin":["YourFantasy"],"clientID":"64f57a27c4b33d7930ff","clientSecret":"34e7c8aa13489f51aa54f53c4734d0e38762b83f","id":"2023-09-17T08:59:43+08:00","owner":"YourFantasy","repo":"blog","title":"GMP调度模型"}},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"id-1":"编程浪子","id-2":"编程浪子"},"lightgallery":true,"search":{"algoliaAppID":"58KPEJ4RD6","algoliaIndex":"index.zh-cn","algoliaSearchKey":"a48c9e27b67c52f03f9b8daa3cbdd18e","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true,"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
