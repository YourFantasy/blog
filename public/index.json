[{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"我的网站\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"这是我的全新 Hugo 网站\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"我的网站\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtu","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 繁體中文 zh-tw zh-TW 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi 阿拉伯语 ar ar 加泰罗尼亚语 ca ca 泰语 th th 泰卢固语 te te 印尼语 id id 土耳其语 tr tr 韩语 ko ko 印地语 hi hi ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" [[languages.en.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[languages.en.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" languageCode = \"zh-CN\" languageName = \"简体中文\" hasCJKLanguage = true [[languages.zh-cn.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" [[languages.fr.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" [[languages.fr.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. 官方提供的 Algolia CLI 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" license: \"\" images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true rssFullText: false toc: enable: true auto: true code: copy: true maxShownLines: 50 math: enable: false # ... mapbox: # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $\\KaTeX$ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. $\\KaTeX$ 根据 特定的分隔符 来自动渲染公式. 技巧 有一份 $\\KaTeX$ 中支持的 $\\TeX$ 函数 清单. 注意 由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染: _ -\u003e \\_ * -\u003e \\* \u003e\u003e -\u003e \\\u003e\u003e \\( -\u003e \\\\( \\) -\u003e \\\\) \\[ -\u003e \\\\[ \\] -\u003e \\\\] \\\\ -\u003e \\\\\\\\ LoveIt 主题支持 raw shortcode 以避免这些转义字符, 它可以帮助您编写原始数学公式内容. 一个 raw 示例: 行内公式: 公式块: 呈现的输出效果如下: 行内公式: 公式块: 行内公式 默认的行内公式分割符有: $ ... $ \\( ... \\) (转义的: \\\\( ... \\\\)) 例如: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\\\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\\\) 呈现的输出效果如下: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 公式块 默认的公式块分割符有: $$ ... $$ \\[ ... \\] (转义的: \\\\[ ... \\\\]) \\begin{equation} ... \\end{equation} (不编号的: \\begin{equation*} ... \\end{equation*}) \\begin{align} ... \\end{align} (不编号的: \\begin{align*} ... \\end{align*}) \\begin{alignat} ... \\end{alignat} (不编号的: \\begin{alignat*} ... \\end{alignat*}) \\begin{gather} ... \\end{gather} (不编号的: \\begin{gather*} ... \\end{gather*}) \\begin{CD} ... \\end{CD} 例如: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}\\_{i}=\\mathbf{E}\\_{1}+\\mathbf{E}\\_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\\\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\\\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\\\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\\\u003e\u003e B \\\\\\\\ @VbVV @AAcA \\\\\\\\ C @= D \\end{CD} 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} 技巧 你可以在 网站配置 中自定义行内公式和公式块的分割符. Copy-tex Copy-tex 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 在选择并复制 $\\KaTeX$ 渲染的公式时, 会将其 $\\LaTeX$ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 $\\LaTeX$ 源代码. mhchem mhchem 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram instagram 的文档 Instagram’s API was deprecated since October 24th, 2020 The instagram-shortcode refers an endpoint of Instagram’s API, that’s deprecated since October 24th, 2020. Thus, no images can be fetched from this API endpoint, resulting in an error when the instagram-shortcode is used. For more information please have a look at GitHub issue #7879. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 917359331535966209 \u003e}} 呈现的输出效果如下: Reminder: This Twitter account is not actively maintained for questions. Please post all questions on https://t.co/yAzbBojxaU #gohugo — GoHugo.io (@GoHugoIO) October 9, 2017 ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["technology"],"content":"深度优先搜索解决连通块问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"题目描述 给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数 n，表示树的结点数。 接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。 输出格式 输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。 数据范围 1≤n≤105 输入样例: 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:1:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"实现思路 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:2:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码实现 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码1 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) son := make(map[int]*listNode) used := make([]bool, n+1) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 2000*1000) scanner.Buffer(buf, len(buf)) for i := 0; i \u003c n-1; i++ { scanner.Scan() ss := strings.Split(scanner.Text(), \" \") var a, b int a, _ = strconv.Atoi(ss[0]) b, _ = strconv.Atoi(ss[1]) add1(son, used, a, b) } res := n dfs1(son, n, 1, \u0026res, make([]bool, n+1)) fmt.Println(res) } func dfs1(mp map[int]*listNode, n, t int, res *int, visited []bool) int { visited[t] = true tmp := 0 sum := 1 for h := mp[t]; h != nil; h = h.next { if !visited[h.val] { s := dfs1(mp, n, h.val, res, visited) tmp = max(tmp, s) sum += s } } tmp = max(tmp, n-sum) *res = min(*res, tmp) return sum } func max(a, b int) int { if a \u003c b { return b } return a } func min(a, b int) int { if a \u003c b { return a } return b } // add 构造图 // son，存储编号为k的节点的孩子节点 // used 编号为b的节点是否曾经是某个节点的孩子节点,是否被用作过孩子节点 // 因为同一个节点只能是一个节点的孩子节点，所以如果b节点之前为某个节点的孩子节点，那么此时b节点是a节点的父节点，a节点是b节点的孩子节点 func add1(son map[int]*listNode, used []bool, a, b int) { if !used[b] { newNode := \u0026listNode{val: b, next: son[a]} son[a] = newNode used[b] = true } else { newNode := \u0026listNode{val: a, next: son[b]} son[b] = newNode } } type listNode struct { val int next *listNode } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:1","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码2 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) h, c, ne := make([]int, n+1), make([]int, 2*n+1), make([]int, 2*n+1) for i := 0; i \u003c= n; i++ { h[i] = -1 } idx := 0 visited := make([]bool, n+1) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 20000*1000) scanner.Buffer(buf, len(buf)) for i := 0; i \u003c n-1; i++ { scanner.Scan() s := scanner.Text() ss := strings.Split(s, \" \") var a, b int a, _ = strconv.Atoi(ss[0]) b, _ = strconv.Atoi(ss[1]) add2(h, c, ne, a, b, \u0026idx) add2(h, c, ne, b, a, \u0026idx) } res := n dfs2(h, c, ne, n, 1, visited, \u0026res) fmt.Println(res) } func dfs2(h, c, ne []int, n, t int, visited []bool, res *int) int { visited[t] = true sum := 1 tmp := 0 for i := h[t]; i != -1; i = ne[i] { if !visited[c[i]] { s := dfs2(h, c, ne, n, c[i], visited, res) sum += s tmp = max(tmp, s) } } tmp = max(tmp, n-sum) *res = min(*res, tmp) return sum } // 建立连接图 // 参考https://www.acwing.com/file_system/file/content/whole/index/content/4446359/ func add2(h, c, ne []int, p, s int, idx *int) { c[*idx] = s ne[*idx] = h[p] h[p] = *idx *idx += 1 } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:2","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"bfs解决最短路问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"题目描述 给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。 输入格式 第一行包含两个整数 n 和 m。 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤100 输入样例： 5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出样例： 8 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:1:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"实现思路 典型的最短路问题，遍历从起始到终点的路径，记录最小值。 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:2:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"代码实现 package main import \"fmt\" const N = 101 func main() { var n, m int fmt.Scanf(\"%d%d\", \u0026n, \u0026m) nums := make([][]int, n) d := make([][]int, n) for i := 0; i \u003c n; i++ { nums[i] = make([]int, m) d[i] = make([]int, m) for j := 0; j \u003c m; j++ { var tmp int fmt.Scanf(\"%d\", \u0026tmp) nums[i][j] = tmp d[i][j] = -1 } } fmt.Println(bfs(nums, d, newQueue(N*N))) } func bfs(nums, d [][]int, q *queue) int { n, m := len(nums), len(nums[0]) d[0][0] = 0 dx := [4]int{-1, 0, 1, 0} dy := [4]int{0, 1, 0, -1} q.push(\u0026pair{0, 0}) for !q.isEmpty() { t := q.pop() for i := 0; i \u003c 4; i++ { // 上下左右四个方向寻找 x, y := t.x+dx[i], t.y+dy[i] // 当前位置的下一个位置 if x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 nums[x][y] == 0 \u0026\u0026 d[x][y] == -1 { d[x][y] = d[t.x][t.y] + 1 q.push(\u0026pair{x, y}) } } } return d[n-1][m-1] } type pair struct { x int y int } type queue struct { elements []*pair begin int end int } func newQueue(n int) *queue { return \u0026queue{ elements: make([]*pair, n), begin: 0, end: -1, } } func (q *queue) push(p *pair) { q.end += 1 q.elements[q.end] = p } func (q *queue) pop() *pair { res := q.elements[q.begin] q.elements[q.begin] = nil q.begin += 1 return res } func (q *queue) isEmpty() bool { return q.end \u003c q.begin } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:3:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"三种工厂模式","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"工厂模式大致可分为 简单工厂模式 工厂方法模式 抽象工厂模式 下面就这三种工厂模式做一下介绍并配上实现代码 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:0:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"简单工厂模式 简单工厂模式，也叫静态方法模式，在对象创建工厂类中定义了一个静态方法来创建对象，简单工厂设计模式让客户端（使用者）无需知道对象的具体细节就能创建出所需的产品实例，使用者可以直接使用生产出来的对象而无需关心对象是如何生产出来的。 类图： 简单工厂模式 代码： package main import \"fmt\" type Animal interface { eat() weight() int } type Dog struct { } func (d *Dog) eat() { fmt.Println(\"dog eat !\") } func (d *Dog) weight() int { return 30 } type Cat struct { } func (c *Cat) eat() { fmt.Println(\"cat eat!\") } func (c *Cat) weight() int { return 10 } type AnimalFactory struct { } func (a *AnimalFactory) newAnimal(animalType int) Animal { switch animalType { case 0: return \u0026Dog{} case 1: return \u0026Cat{} default: return nil } } func main() { factory := new(AnimalFactory) dog := factory.newAnimal(0) dog.eat() fmt.Println(dog.weight()) cat := factory.newAnimal(1) cat.eat() fmt.Println(cat.weight()) } 可以看到简单工厂模式还是挺简单的，实现了将创建实例和使用实例分离，使用者无需关心实例创建过程，实现了分离解耦，无需知道被创建对象的详细信息，只需要知道该对象对应的类型映射即可。那么简单工厂模式有什么缺点呢？在生产对象的时候，根据传入的animal类型来确定创建哪个具体的动物对象，当我们增加更多的annimal种类的时候，比如增加兔子、大象等animal，随着动物种类的越来越多，newAnimal方法就会不断膨胀，并且每次动物种类发生变动的时候，都要去修改这部分代码，不符合开闭原则。 那么如何解决上述问题呢？其实也不能说解决，只能算一个编程小技巧，可以发现newAnimal方法大量的swich case，每次如何干掉这些swich case呢？在main函数中，当我们需要创建某个具体动物对象的时候，需要传入animalType字段然后调用newAnimal方法创建对象，也就是说，我们需要用到某个动物对象的时候才去创建，是一种“懒加载思想”;如果我们每次增加一个新的动物的时候，就创建该动物的实例，然后放到一个map字典中，在要用到该动物的时候，直接从map中取，不就不用维护一个newAnimal方法吗？其实就是把“懒加载思想”转化为“饿加载思想”，不管你用不用我这个对象，我这个对象既然存在，不管三七二十一，就创建一个对象实例塞到map字典里面再说。代码可以改为如下这样： 代码： package main import \"fmt\" // 饿加载，注册到map工厂 func init() { Register(0, \u0026Dog{}) Register(1, \u0026Cat{}) } type Animal interface { eat() weight() int } type Dog struct { } func (d *Dog) eat() { fmt.Println(\"dog eat !\") } func (d *Dog) weight() int { return 30 } type Cat struct { } func (c *Cat) eat() { fmt.Println(\"cat eat!\") } func (c *Cat) weight() int { return 10 } type AnimalFactory struct { } func Register(animalType int, animal Animal) { animals[animalType] = animal } func Get(animalType int) Animal { a, ok := animals[animalType] if !ok { return nil } return a } var animals = make(map[int]Animal) // animal type =\u003e Animal func main() { dog := Get(0) dog.eat() fmt.Println(dog.weight()) cat := Get(1) cat.eat() fmt.Println(cat.weight()) } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:1:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"工厂方法模式 工厂方法模式也叫多态工厂模式，前面介绍了一下简单工厂模式，动物创建工厂无论什么Dog还是Cat都在同一个动物工厂生产，每次需要增加新的动物种类的时候，动物工厂都需要作出相应的改变。就好比，每次生产一个新的动物物种，都需要增加相应的配套工具，这对于系统的扩展性不是很好。工厂方法模式可以看作是对简单工厂模式的一种升级，即不同种类的动物不再在同一个动物工厂生产了，而是进行了细分，每种类型的动物都有一个专门的动物工厂进行生产，这里以汽车作为例子。 类图： 工厂方法模式 代码： package main import \"fmt\" // Car 汽车抽象接口，定义car的两个行为，开车和加油 type Car interface { drive() oil(cnt int) } // Bmw 宝马汽车 type Bmw struct { } func (b *Bmw) drive() { fmt.Println(\"i drive bmw!\") } func (b *Bmw) oil(cnt int) { fmt.Println(\"bmw add \", cnt, \" oil\") } // Benz 奔驰汽车 type Benz struct { } func (b *Benz) drive() { fmt.Println(\"i drive benz!\") } func (b *Benz) oil(cnt int) { fmt.Println(\"benz add \", cnt, \" oil\") } // CarFactory 汽车工厂接口，生产汽车 type CarFactory interface { makeCar() Car } // BmwFactory 宝马汽车工厂，生产宝马汽车 type BmwFactory struct { } func (b *BmwFactory) makeCar() Car { return new(Bmw) } // BenzFactory 奔驰汽车工厂，生产奔驰汽车 type BenzFactory struct { } func (b *BenzFactory) makeCar() Car { return new(Benz) } func main() { bmwFactory := new(BmwFactory) bmw := bmwFactory.makeCar() bmw.drive() bmw.oil(1) benzFactory := new(BenzFactory) benz := benzFactory.makeCar() benz.drive() benz.oil(2) } 简单总结一下工厂方法模式的优缺点： 优点： 1.可扩展性好，当需要增加一款新的产品时（如添加奥迪汽车），无需修改抽象工厂和抽象工厂提供的接口，祝需要添加一个具体工厂和具体产品就行了，更加符合“开闭原则”，简单工厂模式则需要修改工厂类的判断逻辑， 2.符合单一职责原则：每个具体工厂类只负责生产对应的产品。简单工厂模式的工厂类还需要有一定逻辑判断 3.基于⼯⼚⻆⾊和产品⻆⾊的多态性设计是⼯⼚⽅法模式的关键。它能够使⼯⼚可以⾃主确定创建何种产品对象（该产品的工厂类只需要实现抽象工厂接口即可），⽽如何创建这个对象的细节则完全封装在具体⼯⼚内部。⼯⼚⽅法模式之所以⼜被称为多态⼯⼚模式，是因为所有的具体⼯⼚类都具有同⼀抽象⽗类。 缺点： 1.每次添加新的产品，都需要编写新的具体产品类，并且同时也要提供该产品对应的工厂类，当系统中产品数量表多的时候，类的个数会因此成倍增加，会在一定成都上导致系统的复杂性，并且多个类需要编译运行，会在一定程度上增加系统的开销 2.一个具体工厂类只能创建一种具体产品 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:2:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"抽象工厂模式 抽象工厂模式可以理解为生产工厂的工厂，即有一个超级工厂生产其他的工厂。马克思说过：“人是一切社会关系的总和”，一个人在社会上不可能只扮演一种角色，一个人的职业可能是程序员、也有其相应的家庭角色；同时程序员也有go、java、python程序员等，家庭角色也可能是是父亲、儿子、 丈夫等，共同构成了社会关系的总和。抽象工厂模式可以理解为简单工厂模式和工厂方法模式的结合体。自然也继承了各自的优缺点。 类图： 抽象工厂模式 代码： package main import \"fmt\" type programmer interface { writeCode() } type javaProgrammer struct { } func (j *javaProgrammer) writeCode() { fmt.Println(\"i am a java programmer,i write java\") } type goProgrammer struct { } func (g *goProgrammer) writeCode() { fmt.Println(\"i am a golang programmer,i write go\") } type family interface { love() } type father struct { } func (f *father) love() { fmt.Println(\"i am a father ,i love my wife and my son\") } type son struct { } func (s *son) love() { fmt.Println(\"i am a son ,i love my father and my mother\") } type programmerFactory struct { } func (p *programmerFactory) getProgrammer(programmerType int) programmer { switch programmerType { case 0: return new(javaProgrammer) case 1: return new(goProgrammer) default: return nil } } func (p *programmerFactory) getFamily(roleType int) family { return nil } type familyFactory struct { } func (f *familyFactory) getFamily(roleType int) family { switch roleType { case 0: return new(father) case 1: return new(son) default: return nil } } func (f *familyFactory) getProgrammer(programmerType int) programmer { return nil } type abstractHumanFactory interface { getFamily(roleType int) family getProgrammer(programmerType int) programmer } type factoryProducer struct { } func (*factoryProducer) getFactory(factoryType int) abstractHumanFactory { switch factoryType { case 0: return new(programmerFactory) case 1: return new(familyFactory) default: return nil } } func main() { fac := new(factoryProducer) programmerFac := fac.getFactory(0) java := programmerFac.getProgrammer(0) java.writeCode() golang := programmerFac.getProgrammer(1) golang.writeCode() familyFac := fac.getFactory(1) f := familyFac.getFamily(0) f.love() s := familyFac.getFamily(1) s.love() } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:3:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"小结 工厂模式作为最简单也最容易理解同时也是日常使用比较多的一个设计模式，大致可分为三种，在日常开发过程中，正确的使用设计模式能够极大的简化我们的代码，降低代码的耦合度，提升可维护性（毕竟是前人经验的总结），但切记千万不能滥用设计模式，使用不当可能会适得其反，千万不要为了使用设计模式而去使用设计模式！！！ ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:4:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightGallery 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [可选] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. 完整文档请查看页面 主题文档 - mermaid Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts echarts shortcode 使用 ECharts 库提供数据可视化的功能. 完整文档请查看页面 主题文档 - echarts Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. 完整文档请查看页面 主题文档 - mapbox Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 完整文档请查看页面 主题文档 - music Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 完整文档请查看页面 主题文档 - bilibili Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 库提供了打字动画. 完整文档请查看页面 主题文档 - typeit Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12 raw raw shortcode 用来在你的文章中插入原始  HTML 内容. 一个 raw 示例: 行内公式: {{\u003c raw \u003e}}\\(\\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots\\){{\u003c /raw \u003e}} 公式块: {{\u003c raw \u003e}} \\[ a=b+c \\\\ d+e=f \\] {{\u003c /raw \u003e}} 原始的带有 Markdown 语法的内容: {{\u003c raw \u003e}}**Hello**{{\u003c /raw \u003e}} 呈现的输出效果如下: 行内公式: 公式块: 原始的带有 Markdown 语法的内容: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:12:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"13 person person shortcode 用来在你的文章中以 h-card 的格式插入个人网站链接. person shortcode 有以下命名参数: url [必需] (第一个位置参数) URL of the personal page. name [必需] (第二个位置参数) Name of the person. text [可选] (第三个位置参数) Text to display as hover tooltip of the link. picture [可选] (第四个位置参数) A picture to use as person’s avatar. nick [可选] Nickame of the person. 一个 person 示例: {{\u003c person url=\"https://evgenykuznetsov.org\" name=\"Evgeny Kuznetsov\" nick=\"nekr0z\" text=\"author of this shortcode\" picture=\"https://evgenykuznetsov.org/img/avatar.jpg\" \u003e}} 呈现的输出效果为  Evgeny Kuznetsov (nekr0z). 一个使用通用图标的 person 示例: {{\u003c person \"https://www.bardblog.cn/\" Dillon \"author of the LoveIt theme\" \u003e}} 呈现的输出效果为  Dillon. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:13:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["technology"],"content":"贪心算法解决区间合并问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"题目描述 给定 N个闭区间 [ai,bi]，请你在数轴上选择若干个区间，使得选中的区间之间互不相交（包括端点）。 输出可选取区间的最大数量。 输入格式 第一行包含整数 N ，表示区间数。 接下来 N 行，每行包含两个整数 ai,bi ，表示一个区间的两个端点。 输出格式 输出一个整数，表示可选取区间的最大数量。 数据范围 1≤N≤105 , −109≤ai≤bi≤109 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:1:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"代码实现 package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 2000*1024) scanner.Buffer(buf, len(buf)) points := make([][]int, n) for i := 0; i \u003c n; i++ { scanner.Scan() strList := strings.Split(scanner.Text(), \" \") a, _ := strconv.Atoi(strList[0]) b, _ := strconv.Atoi(strList[1]) points[i] = []int{a, b} } sort.Slice(points, func(i, j int) bool { return points[i][1] \u003c points[j][1] }) cnt := 1 rightPoint := points[0][1] for i := 1; i \u003c n; i++ { if points[i][0] \u003e rightPoint { cnt++ rightPoint = points[i][1] } } fmt.Println(cnt) } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:2:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"证明 先把原始区间按照右端点从小到大排序 对于第一个区间，选择右端点 从第二个区间开始，判断两个区间是否有交集，如果有交集，则合并两个区间（rightPoint是合并之前区间内最小右端点）；否则不相交区间+1 对于第k个区间，如果当前区间和前面所有区间（如果当前区间的左端点大于之前区间的最小右端点）都不相交， 不相交区间+1 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:3:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["documentation"],"content":"mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":" mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. mermaid 是一个可以帮助你在文章中绘制图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:5:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:6:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"实体关系图 一个 实体关系图 mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:7:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"用户体验旅程图 一个 用户体验旅程图 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:8:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:9:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"依赖图 一个 依赖图 mermaid 示例: {{\u003c mermaid \u003e}} requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:10:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["Markdown"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"表情与情感 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人与身体 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"动物与自然 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"活动 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"物品 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"符号 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旗帜 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能. ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":" mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":" bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["technology"],"content":"缓存淘汰算法LRU和LFU及其实现","date":"2023-09-16","objectID":"https://www.bardblog.cn/algorithm-cache-obsolescence/","tags":["Redis","Algorithm","Cache"],"title":"LFU和LRU缓存淘汰算法","uri":"https://www.bardblog.cn/algorithm-cache-obsolescence/"},{"categories":["technology"],"content":"前言 在日常开发过程中以及操作系统和许多开源项目中，为了提高性能，我们经常会使用缓存。缓存实际上是一种空间换时间的策略，通过将数据存储在快速访问的存储介质中，以减轻底层数据源的访问压力并提高系统性能。以日常开发为例，通常我们会将缓存数据存储在内存这种容量较小、速度快、价格较高的存储介质中。一个优秀的缓存系统通常需要考虑以下几个方面： 设置缓存占用内存空间上限，防止无限制增长导致服务内存溢出（OOM）。 分片策略，降低锁粒度。 选择合适的哈希算法，减少哈希碰撞。 使用singleflight策略，降低缓存击穿的风险。 采用合适的缓存淘汰策略，淘汰数据以释放存储空间。 设置缓存过期时间，减少内存空间占用并缩小数据不一致性的时间窗口。 使用高效的数据结构，平衡时间复杂度和空间复杂度。 监控告警，关注缓存击穿率和缓存命中率。 实现缓存持久化和预热。 本文将主要讨论两种常用的缓存淘汰策略的原理及其实现。 ","date":"2023-09-16","objectID":"https://www.bardblog.cn/algorithm-cache-obsolescence/:1:0","tags":["Redis","Algorithm","Cache"],"title":"LFU和LRU缓存淘汰算法","uri":"https://www.bardblog.cn/algorithm-cache-obsolescence/"},{"categories":["technology"],"content":"缓存淘汰算法 正如前面所提到的，为了避免内存溢出（OOM），缓存系统通常需要设置最大容量上限。这意味着缓存系统中存储的数据是有限的。假设我们现在有一个容量为10的缓存系统，任意时刻最多只有10条数据在缓存中。如果不考虑缓存设置过期时间，那么问题来了：是不是谁先占据这10个位置，其他数据就永远没有机会被放入缓存中？显然，这样的缓存系统并没有太大意义。 正如一个正常的社会应该有良好的阶级流动而非阶级固化一样，一个优秀的缓存系统中的数据也应该是流动的而非僵化的。为了实现这一目标，我们需要一种策略来清空部分数据，从而为新数据腾出空间。那么，我们应该如何淘汰数据呢？是随机淘汰，还是按照某种规则进行淘汰？这个策略就是本文要讨论的“缓存淘汰算法”。 ","date":"2023-09-16","objectID":"https://www.bardblog.cn/algorithm-cache-obsolescence/:2:0","tags":["Redis","Algorithm","Cache"],"title":"LFU和LRU缓存淘汰算法","uri":"https://www.bardblog.cn/algorithm-cache-obsolescence/"},{"categories":["technology"],"content":"LRU LRU（Least Recently Used，最近最少使用）是一种常用的缓存淘汰算法。它的核心思想是：当缓存空间不足时，优先淘汰最近最少使用的数据。LRU算法基于这样一个假设：最近访问过的数据在未来仍有较高的可能性被访问，因此应该将其保留在缓存中。 所谓“最近最少使用”，是指在一段时间内，某个数据相对于其他数据被访问的次数较少或者距离上次访问的时间较长。举个例子，假设你经常去北京、上海、天津和武汉这四个地方，但是最近一段时间你很长时间没有去武汉了。在这种情况下，武汉可以被视为“最近最少使用”的数据。对于缓存系统来说，它就会认为你好久没去武汉了，以后可能也不会去了，如果要去其它地方，那干脆把它从缓存中去掉吧，给新的数据腾位子。 这就是LRU缓存淘汰算法的基本思路。当缓存空间不足以容纳新数据时，它会选择最近最少使用的数据进行淘汰，从而为新数据腾出空间。这种策略有助于保留那些近期频繁访问的数据，从而提高缓存的命中率。当然，这种策略并非绝对准确，因为未来的访问模式可能会发生变化，但在实际应用中，LRU算法往往能够取得较好的性能。 为了实现这种效果，我们需要知道哪些数据是最近访问的，并按照某种顺序或权重记录缓存数据的优先级。当需要淘汰数据时，优先淘汰低优先级的数据。这就要求每次访问都需要让本次访问的数据优先级最高，避免被淘汰，实际上是一种贪心策略。 对于一个缓存系统来说，对外实际上主要提供两个能力：get和set。每次读取数据时，会将该数据的优先级设置为最高；每次写数据时，也会将数据放到最高优先级的位置。为了实现这一目标，我们通常会使用哈希表（HashMap），它能够在O(1)的时间复杂度内获取数据以及判断缓存是否存在。而对于要求数据通过优先级有序的场景，我们可以使用双链表这种数据结构。综合考虑，我们可以使用哈希表+双链表来实现LRU算法。 在这种实现中，哈希表负责快速查找缓存项，双链表负责维护缓存项的访问顺序。当访问或更新缓存时，我们可以在O(1)时间内通过哈希表找到对应的缓存项，然后将其移动到双链表的头部。当需要淘汰缓存时，我们可以直接移除双链表尾部的缓存项（最近最少使用的数据）。这样，我们就能在O(1)时间内完成缓存的读取、更新和淘汰操作，从而实现高效的LRU缓存淘汰算法。 优先级更新及淘汰过程 代码实现 package main import ( \"errors\" \"fmt\" \"sync\" ) func main() { const size = 20 l := NewLRU(size) for i := 0; i \u003c size+1; i++ { l.Add(fmt.Sprintf(\"%d\", i+1), (i+1)*100) } fmt.Println(l.Get(\"3\")) fmt.Println(l.Get(\"4\")) fmt.Println(l.Get(\"5\")) fmt.Println(l.Get(\"50\")) l.Iterator() for i := 0; i \u003c size+1; i++ { fmt.Printf(\"%p,%+v\\n\", l.dict[fmt.Sprintf(\"%d\", i+1)], l.dict[fmt.Sprintf(\"%d\", i+1)]) } } var ErrNotExist = errors.New(\"not exist\") type LRU struct { head *listNode tail *listNode dict map[string]*listNode size int mu sync.RWMutex } // NewLRU 新建一个LRU实例 func NewLRU(size int) *LRU { head := \u0026listNode{} tail := \u0026listNode{} head.right = tail tail.left = head return \u0026LRU{ head: head, tail: tail, dict: make(map[string]*listNode, size), size: size, mu: sync.RWMutex{}, } } func (l *LRU) Get(key string) (int, error) { l.mu.Lock() defer l.mu.Unlock() node := l.dict[key] if node == nil { return 0, ErrNotExist } l.cacheHit(node) return node.val, nil } func (l *LRU) Add(key string, val int) { l.mu.Lock() defer l.mu.Unlock() var newNode *listNode if _, ok := l.dict[key]; ok { newNode = l.dict[key] newNode.val = val l.cacheHit(newNode) return } newNode = \u0026listNode{ key: key, val: val, } var node *listNode if len(l.dict) \u003e= l.size { node = l.tail.left } if node != nil { l.tail.left = node.left node.left.right = l.tail delete(l.dict, node.key) } newNode.right = l.head.right l.head.right.left = newNode newNode.left = l.head l.head.right = newNode l.dict[key] = newNode } func (l *LRU) cacheHit(node *listNode) { node.left.right = node.right node.right.left = node.left node.right = l.head.right l.head.right.left = node node.left = l.head l.head.right = node } // Iterator 遍历LRU func (l *LRU) Iterator() { l.mu.Lock() defer l.mu.Unlock() t := l.head.right for ; t != l.tail; t = t.right { fmt.Printf(\"key:%d,val:%d \", t.key, t.val) } fmt.Println() } type listNode struct { left *listNode right *listNode key string val int } ","date":"2023-09-16","objectID":"https://www.bardblog.cn/algorithm-cache-obsolescence/:2:1","tags":["Redis","Algorithm","Cache"],"title":"LFU和LRU缓存淘汰算法","uri":"https://www.bardblog.cn/algorithm-cache-obsolescence/"},{"categories":["technology"],"content":"LFU 前面提到，假设你可能会经常访问北京、上海、天津和武汉这四个城市。有一段时间内没去武汉，使用LRU淘汰策略把这个数据从缓存中剔除。这看似合理，但实际上可能存在误伤。因为没去武汉的原因可能是以后不会再去了，也可能是这段时间内遇到了突发情况，比如买不到票或者武汉天气不太好。实际上，在最近这段时间之前，你去武汉的频率可能是最高的。在这种情况下，淘汰武汉这个数据可能并不合适。这就引申出另外一种缓存淘汰策略——LFU，它会记录每个数据的访问次数，并按照访问次数排序，将访问次数最低的数据视为低优先级数据。 LFU（Least Frequently Used，最不经常使用）是一种常用的缓存淘汰算法。它的核心思想是：当缓存空间不足时，优先淘汰访问频率最低的数据。LFU算法基于这样一个假设：访问频率较低的数据在未来被访问的可能性也较低，因此将其从缓存中移除。 为了实现LFU算法，我们需要记录每个数据项的访问频率。通常，可以使用哈希表来存储缓存项及其对应的访问频率。当访问或更新缓存时，我们需要更新对应数据项的访问频率。当需要淘汰缓存时，我们需要找到访问频率最低的数据项并将其移除。为了高效地找到访问频率最低的数据项，我们可以使用一种特殊的数据结构，如最小堆或者使用多个双链表，每个双链表代表一个访问频率，链表中的缓存项按照访问时间排序。 相较于LRU算法，LFU算法更加关注数据项的访问频率，而不仅仅是最近的访问时间。这使得LFU算法在某些场景下能够更好地预测未来的访问模式，从而提高缓存的命中率。然而，LFU算法的实现通常比LRU算法更复杂，且在数据访问频率分布较为平均的场景下，LFU算法的优势可能不会非常明显。 根据访问频率更新及淘汰过程 代码实现 package main import ( \"fmt\" \"sort\" \"sync\" ) func main() { const size = 20 l := NewLFU(size) for i := 0; i \u003c size; i++ { l.Add(i+1, (i+1)*100) } fmt.Println(l.Get(3)) fmt.Println(l.Get(4)) fmt.Println(l.Get(5)) fmt.Println(l.Get(4)) l.Add(22, 2200) l.Add(23, 2300) l.Add(24, 2400) l.Add(23, 23000) // l.Iterator() const ( shardNum = 256 eachShardCapacity = 1000 ) fmt.Println(\"======cache\") cache := NewLocalCache(shardNum, eachShardCapacity) for i := 0; i \u003c shardNum*eachShardCapacity; i++ { cache.Add(i+1, (i+1)*10) } for i := 0; i \u003c shardNum \u0026\u0026 i*10+10 \u003c shardNum; i++ { fmt.Println(len(cache.cacheList[i*10+10].dict)) } } type LocalCache struct { cacheList []LFU shardNum int } func NewLocalCache(shardNum int, eachSharCapacity int) LocalCache { cacheList := make([]LFU, shardNum) for i := 0; i \u003c len(cacheList); i++ { cacheList[i] = NewLFU(eachSharCapacity) } return LocalCache{ cacheList: cacheList, shardNum: shardNum, } } func (l *LocalCache) Add(key, val int) { index := hash(key) % l.shardNum l.cacheList[index].Add(key, val) } func (l *LocalCache) Get(key int) int { index := hash(key) % l.shardNum return l.cacheList[index].Get(key) } // LFU is a structure for LFU cache. type LFU struct { dict map[int]*listNode // dict stores the key-value pairs. freqDict map[int]*freqNode // freqDict stores the frequency of each key. minFrequency int // minFrequency stores the minimum frequency. capacity int // capacity is the capacity of the cache. mu sync.Mutex // mu is used for ensuring thread safety. } // NewLFU creates a new LFU cache. func NewLFU(capacity int) LFU { return LFU{ dict: make(map[int]*listNode, capacity), freqDict: make(map[int]*freqNode, capacity), minFrequency: 0, capacity: capacity, mu: sync.Mutex{}, } } // listNode is a node in the doubly linked list. type listNode struct { left, right *listNode // left and right are pointers to adjacent nodes. key, val int // key and val are the key and value of the node. accessTimes int // accessTimes is the number of times the node has been accessed. } // freqNode is a node in the frequency list. type freqNode struct { head, tail *listNode // head and tail are pointers to the head and tail of the list. size int // size is the number of nodes in the list. } // Add adds a key-value pair to the cache. func (l *LFU) Add(key, val int) { l.mu.Lock() // Lock the cache. defer l.mu.Unlock() // Unlock the cache when the function returns. node, ok := l.dict[key] if ok { node.val = val l.hitIncrease(node) return } if len(l.dict) == l.capacity { freq := l.freqDict[l.minFrequency] minNode := freq.tail.left minNode.left.right = freq.tail freq.tail.left = minNode.left freq.size -= 1 delete(l.dict, minNode.key) if freq.size == 0 { delete(l.freqDict, l.minFrequency) } } l.minFrequency = 1 node = \u0026listNode{ key: key, val: val, accessTimes: 1, } freq, ok := l.freqDict[node.accessTimes] if !ok { freq = newFreqNode() l.freqDict[node.accessTimes] = freq } freq.size += 1 freq.add(node) l.dict[key] = node } // Get gets the value of a key from the cache. func (l *LFU) Get(key int) int { l.mu.Lock() // Lock the cache. defer l.mu.Unlock() // Unlock the cache when the function returns. node, ok := l.dict[key] if !ok { return -1 } l.hitIncrease(node) return node.val } // hitIncrease increases the access ti","date":"2023-09-16","objectID":"https://www.bardblog.cn/algorithm-cache-obsolescence/:2:2","tags":["Redis","Algorithm","Cache"],"title":"LFU和LRU缓存淘汰算法","uri":"https://www.bardblog.cn/algorithm-cache-obsolescence/"},{"categories":["technology"],"content":"负载均衡算法 在分布式系统中，一般来说会有多台机器，机器可能会分布在不同的集群，客户端的一个请求经过服务注册中心或者网关，注册中心或者网关会根据负载均衡算法将本次请求分发到某台具体的服务器，负载均衡算法主要用于分配网络或计算资源，以优化响应时间和避免过度负载任何一个资源常见的有如下的负载均衡算法： 负载均衡算法主要用于分配网络或计算资源，以优化响应时间和避免过度负载任何一个资源。以下是一些常见的负载均衡算法： 轮询（Round Robin）：这是最简单的负载均衡算法，它将请求按顺序分配给服务器。当到达最后一个服务器时，算法会返回到队列的顶部并重新开始。 加权轮询（Weighted Round Robin）：这是轮询的一个变种，它考虑到了服务器的处理能力。每个服务器都被分配一个权重，权重较高的服务器将接收更多的请求。 最少连接（Least Connections）：这种算法将新的请求分配给当前连接数最少的服务器。这对于处理时间较长的请求非常有效。 加权最少连接（Weighted Least Connections）：这是最少连接算法的一个变种，它考虑到了服务器的处理能力。每个服务器都被分配一个权重，权重较高的服务器将接收更多的请求。 随机（Random）：这种算法将请求随机分配给服务器。 最短响应时间（Least Response Time）：这种算法将请求分配给响应时间最短的服务器。 普通哈希（Hash）：这种算法根据源IP地址或者请求入参的哈希值来分配请求。这样可以保证来自同一源IP地址或者同一个请求总是被分配给同一台服务器。 一致性哈希（Consistent Hashing）：对普通Hash算法的一个改进，这种算法主要用于分布式系统，它可以在服务器集群的数量发生变化时，最小化重新分配的数据。 设想我们有这样一个场景：有一个分布式服务，我们需要为这个服务构造一个本地缓存，当服务的机器数很多的时候，同一个key可能在多台机器上都会有缓存，如果要缓存的数据量很大的时候，同一台机器上key过多可能会导致机器内存占用率过高，严重的可能会发生OOM，这就要求缓存的key散列的分布在不同的机器上，减少单台机器的负载，需要构造一个请求入参和机器的映射关系，让相同的请求打到相同的机器上。应该采用上述何种算法提高缓存的命中率并减少缓存占用空间呢？1-6的算法，一个请求打到哪台服务器随机性很大，7-8都是hash算法，如果把请求入参hash，理论上可以保证同样的请求达到同样的机器上的。 hash负载均衡 如上图所示，假设这个服务有A/B/C/D四台机器，每台机器负责一部分请求，和普通的hash算法不同的是，一致性hash把一个结点化整为零拆分成多个虚拟子结点，所有机器的子结点构成了一个环，按照子结点负责的hash值进行排序，这样做的主要有两个好处：一是让请求更加离散最大程度上减少请求聚集避免单点承载过重，二是在发生扩缩容请求调度的时候能够以较小的代价完成调度的过程。 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:1:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"代码实现 package main import ( \"crypto/rand\" \"encoding/hex\" \"fmt\" \"hash/fnv\" \"net\" \"sort\" \"sync\" ) const ( keySize = 1000 traceIDLen = 16 ringSize = 100 ) func main() { hr := NewHashRing([]ServerNode{ { Name: \"grpc.app.server1.service1\", Weight: 0.89, }, { IP: net.ParseIP(\"123.33.32.1\"), Port: 8932, Weight: 0.73, }, { IP: net.ParseIP(\"123.33.32.1\"), Port: 8933, }, { IP: net.ParseIP(\"234.65.32.3\"), Port: 8932, Weight: 1, }, { IP: net.ParseIP(\"231.23.32.11\"), Port: 32322, Weight: 1.11, }, }) keys := make([]string, keySize*2) for i := 0; i \u003c keySize; i++ { keys[i] = generateTraceID() keys[2*keySize-i-1] = keys[i] } for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } fmt.Println(\"AddNodes====================\") hr.AddNodes( ServerNode{IP: net.ParseIP(\"132.232.123.223\"), Port: 1923, Weight: 0.91}, ServerNode{Name: \"trpc.app.server2.service1\", Weight: 1.21}, ) for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } fmt.Println(\"RemoveNodes====================\") hr.RemoveNodes(hr.GetNode(keys[0]), hr.GetNode(keys[1]), hr.GetNode(keys[3])) for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } } // HashRing 哈希环 // nodes 真实结点 // virtualNodes n个虚拟节点指向一个实际节点,一个实体节点变成n个虚拟结点，均匀打散。 type HashRing struct { nodes map[string]ServerNode virtualNodes map[uint32]ServerNode sortedHashes []uint32 mu sync.RWMutex } // ServerNode 服务器结点信息 type ServerNode struct { Name string // 服务名 IP net.IP // ip地址 Port uint16 // 端口 Weight float32 // 权重 } // NewHashRing 新建一个hash环 func NewHashRing(nodes []ServerNode) *HashRing { ns := make(map[string]ServerNode, len(nodes)) for _, nd := range nodes { ns[nd.String()] = nd } hr := \u0026HashRing{nodes: ns, virtualNodes: map[uint32]ServerNode{}} hr.virtualNodes = hr.generateVirtualNodes() hr.sortedHashes = hr.genSortedHashes() hr.mu = sync.RWMutex{} return hr } // AddNodes 添加结点 func (h *HashRing) AddNodes(nodes ...ServerNode) { h.mu.Lock() defer h.mu.Unlock() for _, node := range nodes { if _, ok := h.nodes[node.String()]; ok { continue } h.nodes[node.String()] = node h.addVirtualNodes(node) } h.sortedHashes = h.genSortedHashes() } // RemoveNodes 移除结点 func (h *HashRing) RemoveNodes(nodes ...ServerNode) { h.mu.Lock() defer h.mu.Unlock() for _, node := range nodes { delete(h.nodes, node.String()) h.deleteVirtualNodes(node) } h.sortedHashes = h.genSortedHashes() } // GetNode 获取结点 func (h *HashRing) GetNode(key string) ServerNode { h.mu.RLock() // Use read lock instead of write lock defer h.mu.RUnlock() if len(h.virtualNodes) == 0 { return ServerNode{} } hashValue := hash(key) if h.sortedHashes[len(h.sortedHashes)-1] \u003c hashValue { return h.virtualNodes[h.sortedHashes[0]] } i, j := 0, len(h.sortedHashes)-1 for i \u003c j { mid := i + (j-i)/2 if h.sortedHashes[mid] \u003e= hashValue { j = mid } else { i = mid + 1 } } if h.sortedHashes[i] \u003e= hashValue { return h.virtualNodes[h.sortedHashes[i]] } return h.virtualNodes[h.sortedHashes[0]] } func (h *HashRing) generateVirtualNodes() map[uint32]ServerNode { virtualNodes := make(map[uint32]ServerNode) for _, node := range h.nodes { for i := 0; i \u003c int(ringSize*node.Weight); i++ { virtualNode := fmt.Sprintf(\"%s#%d\", node, i) virtualNodes[hash(virtualNode)] = node } } return virtualNodes } func (h *HashRing) addVirtualNodes(node ServerNode) { for i := 0; i \u003c int(ringSize*node.Weight); i++ { virtualNode := fmt.Sprintf(\"%s#%d\", node, i) h.virtualNodes[hash(virtualNode)] = node } } func (h *HashRing) deleteVirtualNodes(node ServerNode) { for i := 0; i \u003c int(ringSize*node.Weight); i++ { delete(h.virtualNodes, hash(fmt.Sprintf(\"%s#%d\", node, i))) } } func (h *HashRing) genSortedHashes() []uint32 { hashes := make([]uint32, 0, len(h.virtualNodes)) for node := range h.virtualNodes { hashes = append(hashes, node) } sort.Slice(hashes, func(i, j int) bool { return hashes[i] \u003c hashes[j] }) return hashes } func hash(key string) uint32 { h := fnv.New32a() _, _ = h.Write([]byte(key)) return h.Sum32() } func (s ServerNode) equal(node ServerNode) bool { if len(s.Name)","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:2:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"调度过程 在服务扩容或缩容的过程中，请求的转移是不可避免的。这个过程类似于Kafka的rebalance操作，即重新调度资源分配。然而，Kafka的rebalance过程的一个缺点是它相对较慢，这是由于Kafka的高吞吐量和高可用性所决定的。一致性哈希算法的优点在于整个rebalance过程会非常快，这样可以更好地应对服务请求量波动导致的扩缩容。 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:3:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"服务扩容 假设我们现在有A、B、C和D四台机器，通过一致性哈希算法，每台机器负责一部分的请求。当流量增加或出现热点问题导致请求量增加时，服务会自动扩容出一台新的机器E。在这个过程中，调度机制会首先计算E机器对应的虚拟节点负责的哈希范围，然后通过插入排序的方式，将新的虚拟节点插入到已有的哈希环中。最后，更新服务的路由信息，使得新的请求逐步平滑地从原有节点迁移到新扩容出来的节点。整个过程如下： 计算新机器E对应的虚拟节点负责的哈希范围。 将新的虚拟节点插入到已有的哈希环中，使用插入排序的方式。 更新服务的路由信息，使得新的请求逐步平滑地从原有节点迁移到新扩容出来的节点。 扩容调度过程 通过这种方式，一致性哈希算法可以快速地进行服务扩容，更好地应对服务请求量波动导致的扩缩容。 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:3:1","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"服务缩容 上面介绍了扩容的过程，缩容过程与扩容相似。假设B机器因为长期低负载和较小的请求量触发了缩容策略，导致机器被回收。在这种情况下，调度机制会在哈希环中移除所有与B机器相关的虚拟节点，并更新路由信息。此时，原先B服务器虚拟节点负责的请求哈希范围会均匀地分散到其他机器的虚拟节点上。 由于整个哈希环中，如果哈希算法足够均匀，那么A、B、C和D四台机器对应的虚拟节点也是离散分布的。这样，在缩容后，剩下的三台机器不会出现某台机器承载过重的情况，从而避免了雪崩效应。通过这种方式，一致性哈希算法在服务缩容过程中能够快速地进行资源调度，确保系统的稳定性和可用性。 缩容调度过程 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:3:2","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"小结 一致性hash算法调度过程的关键点如下： 一致性哈希算法在服务扩容和缩容过程中能够快速地进行资源调度，以应对服务请求量波动导致的扩缩容。 在扩容过程中，新的虚拟节点会被插入到已有的哈希环中，并更新路由信息，使得新的请求逐步平滑地从原有节点迁移到新扩容出来的节点。 在缩容过程中，被回收机器的虚拟节点会从哈希环中移除，并更新路由信息，使得原先负责的请求哈希范围均匀地分散到其他机器的虚拟节点上。 一致性哈希算法通过离散分布的虚拟节点，确保在扩缩容过程中不会出现某台机器承载过重的情况，从而避免了雪崩效应。 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:3:3","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"实际应用 一致性哈希算法在实际应用中有很多场景，以下是一些常见的应用： 分布式缓存：在分布式缓存系统（如Redis、Memcached）中，一致性哈希算法被用于将缓存数据分布在多个缓存节点上。当缓存节点发生扩容或缩容时，一致性哈希算法能够保证数据重新分布的过程中，尽量减少数据迁移的数量，从而降低缓存失效的概率。 负载均衡：在分布式系统中，负载均衡器（如Nginx、HAProxy）可以使用一致性哈希算法将客户端请求分发到不同的服务器上。这样，在服务器扩容或缩容时，可以保证客户端请求的重新分配过程更加平滑，避免某些服务器过载。 分布式存储：在分布式存储系统（如Cassandra、HBase）中，一致性哈希算法被用于将数据分片存储在多个节点上。当存储节点发生扩容或缩容时，一致性哈希算法能够保证数据重新分布的过程中，尽量减少数据迁移的数量，从而降低数据不一致的风险。 分布式锁：在分布式锁系统（如ZooKeeper、etcd）中，一致性哈希算法可以用于将锁资源分布在多个锁服务器上。这样，在锁服务器扩容或缩容时，可以保证锁资源的重新分配过程更加平滑，避免某些锁服务器过载。 一致性哈希算法在实际应用中有很多场景，主要用于解决分布式系统中的数据分布、负载均衡和动态扩缩容等问题。 ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:4:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"概念 跳表是一种很特殊的数据结构，可以把跳表理解为一个多层链表，每一层都是一个有序链表，链表之间通过指针连接，并且最底层的那个链表保存跳表完整的元素，跳表示意图如下： 跳表示意图 可以看到除了最后一层链表，每一层链表元素都有可能缺失。 小结一下跳表的基本特征： 每一层都是一个按照结点的score有序的链表 链表结点key全局唯一，score可以相同 不同层链表相同结点之间通过指针相连 最底层链表含有跳表所有元素 由此可以抽象化出跳表的数据结构： // skipList 跳表数据结构 // Data 链表结点数据 // next 指向下一个节点指针，同一层链表结点按照Score非递减 // down，与下一层连接指针，当前节点p p!=nil\u0026\u0026p.down!=nil 满足 p.Data==p.down.Data type skipList struct { Data Data next *skipList down *skipList } // Data 数据类型 type Data *Element // Element 链表结点格式 // Key: zSet的成员key，全局唯一 // Score: zSet的成员对应的分数，可以一样 type Element struct { Key string Score int } ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:1:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"插入流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:2:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"删除流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:3:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"更新流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:4:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"查询流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:5:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"代码实现 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:6:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"实际应用 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:7:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"介绍MySQL的核心概念","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"MySQL 介绍MySQL的一些核心概念以及它们的底层实现,以下都是基于MySQL的InnoDB存储引擎。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:0:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"SQL语句执行流程 我们刚开始学习SQL的时候，第一个学的就是select语句了，以下就是一条最简单的查询语句: // 在student表中查询一条id为1的记录 select * from student where id=1; 那么执行这条SQL语句的全流程是什么呢？MySQL内部执行这条简单的SQL语句都做了哪些事，内部发生了什么呢？带着疑问开始学习MySQL，了解MySQL的内部架构。 先从全局的角度来看一条SQL语句的执行流程，从图中可以看到SQL语句从客户端到到数据存储整个流程以及MySQL的架构所包含的模块。 MySQL执行流程 可以看到MySQL内部分为两层，Server层和存储引擎层。 Server层负责建立和客户端连接、分析、优化和执行SQL语句。Server层和存储引擎无关，MySQL的核心模块都是在Server层实现，包括连接器、解析器、预处理器、优化器、执行器，此外MySQL的内置函数和所有跨存储引擎的功能都是在Server层实现/。 存储引擎层负责数据的提取和存储。存储引擎有多重，常见的有InnoDB、MyISAM、Memory，提供给Server层的接口都是一样的，只是具体实现不同。本文主要就InnodDB存储引擎展开，InnoDB也是MySQL的默认存储引擎。我们熟悉的MySQL的一些概念，如索引、事务、锁等都是在存储引擎层实现的，InnoDB的索引类型是B+树，我们在数据库表中创建的主键索引、联合索引、普通索引等都是用的B+树索引 以上介绍了一下MySQL的整体架构，总的架构来说“不算复杂”，就Server层和存储引擎层，下面就具体细节展开。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"连接器 如果想要对MySQL进行增删改查操作，首先肯定是要和MySQL建立连接才能继续接下来的操作，一般使用如下命令和MySQL服务建立连接。 # -h 指定域名或者ip地址 # -u 指定用户名 # -p 指定密码，从风险角度考量一般不写死，而是在执行命令后手动在控制台输入 mysql -h ip -u user -p 如： mysql -h 192.168.1.111 -u root -p 因为MySQL的的传输层协议是基于TCP的，所以建立连接的过程需要经过TCP三次握手。如果MySQL服务器运行正常，在建立TCP连接后，会验证我们的用户名和密码是否正确，如果用户名或者密码不对，就会报错：Access denied for user。如果用户名和密码都是ok的，连接器就会根据用户名查询改用户具有的权限，把权限保存在内存里，在改次连接断开之前，即便是管理员修改了用户的权限，也不会影响用户在本次连接的权限，只会在下次建立连接的时候才会使用新的权限，在本次连接生命周期中，用户的所有读写操作的权限都是基于认证的时候保存在内存的权限。 可以使用如下命令查看当前mysql服务器建立的脸颊情况 mysql\u003e show processlist; +----------+------+--------------------+-------------+---------+------+-------+------------------+ | Id | User | Host | db | Command | Time | State | Info | +----------+------+--------------------+-------------+---------+------+-------+------------------+ | 10773010 | root | 10.99.17.131:21086 | NULL | Sleep | 210 | | NULL | | 10773094 | root | 10.99.17.131:23980 | mysql_learn | Sleep | 72 | | NULL | | 10773150 | root | 10.99.17.131:25924 | NULL | Query | 0 | init | show processlist | +----------+------+--------------------+-------------+---------+------+-------+------------------+ 3 rows in set (0.02 sec) 可以看到,有三个用户名为root的用户和MySQL服务建立了连接，其中Id为10773010的用户使用的db是空而且Commond的值是Sleep，意味着该用户执行连接命令后没有再执行过其它任何命令，并且空闲等待的时间为210s（Time列） 那么这个空闲等待时间会一直无限递增吗？换句话说MySQL连接会一直保存着吗？ 肯定是不可能的，不可能我一年前建立的一个连接然后忘了啥都没干，但是MySQL还记着一直给我保存着，显然这是不可能的（就好比去餐厅吃饭，预约了一个座位，超过一定时间没去肯定会给你取消的），MySQL也有类似的机制，如果一个连接长期在哪空转啥都不干，超过一定时间内就会自动断开，这个断开时间（最大空闲时常）是由 wait_timeout这个参数控制的，默认的是26060=7200s。 mysql\u003e show variables like 'wait_timeout'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 7200 | +---------------+-------+ 1 row in set (0.03 sec) 如果我们看某个连接不爽，也可以使用 kill connection +Id命令手动kill这个连接，我现在想要干掉10773010这个连接，只需要执行如下命令： mysql\u003e kill connection +10773010; Query OK, 0 rows affected (0.02 sec) mysql\u003e show processlist; +----------+------+--------------------+-------------+---------+------+-------+------------------+ | Id | User | Host | db | Command | Time | State | Info | +----------+------+--------------------+-------------+---------+------+-------+------------------+ | 10773094 | root | 10.99.17.131:23980 | mysql_learn | Sleep | 895 | | NULL | | 10773150 | root | 10.99.17.131:25924 | NULL | Query | 0 | init | show processlist | +----------+------+--------------------+-------------+---------+------+-------+------------------+ 2 rows in set (0.03 sec) mysql\u003e 可以看到10773010这个连接已经被kill掉了 可以无限和MySQL服务器建立连接吗？ 就像任何资源都是有上限的，MySQL的连接也是宝贵的资源，肯定不会也不能无限提供，就像最大空闲市场是由wait_timeout这个参数控制的一样，最大连接数是由 max_connections参数控制的 mysql\u003e show variables like 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 2500 | +-----------------+-------+ 1 row in set (0.03 sec) mysql\u003e 比如我的MySQL服务器的最大连接数是2500，意味着在同一时刻最多只能保持2500个连接，超过这个值，系统会拒绝接下来的连接请求，并且报错Too many connections。 我们知道HTTP协议是基于TCP协议的，HTTP有长连接和短连接，同样的MySQL也有长连接和短连接。 长连接：顾名思义，存活周期很长的连接，客户端在和MySQL建立连接后，每次执行完一条SQL语句，连接不会马上释放，而是保存着，下次再执行SQL语句不用重复建连了，而是可以复用这条连接。 短连接：故名思义，存活周期较短的连接，客户端在和MySQL建立连接后，每次执行完一条SQL语句，连接马上释放，下次再执行SQL语句需要重新建连。 # 长连接 经过tcp三次握手和MySQL建立连接 执行sql1 执行sql2 执行sql3 .... 执行sqln 经过tcp四次挥手和MySQL断开链接。 # 短连接 经过tcp三次握手和MySQL建立连接 执行sql1 经过tcp四次挥手和MySQL断开链接。 经过tcp三次握手和MySQL建立连接 执行sql2 经过tcp四次挥手和MySQL断开链接。 经过tcp三次握手和MySQL建立连接 执行sql3 经过tcp四次挥手和MySQL断开链接。 .... 经过tcp三次握手和MySQL建立连接 执行sqln 经过tcp四次挥手和MySQL断开链接。 可以看到长连接和短连接各有优劣。 长连接的好处在于不用每次执行SQL语句都建立连接，做到资源复用，而且可以降低SQL语句耗时（省去建立连接的三次握手过程）；坏处在于连接长期得不到释放，连接是需要占用MySQL的系统资源的，如果长连接累积的很多，可能会导致MySQL系统OOM，所以最大连接数不能配置的太高。 短连接的好处在于每次执行完SQL语句连接都被释放掉了，降低MySQL系统负载，坏处是每次执行SQL语句都需要建立连接，会增加SQL语句执行耗时。 在实际开发过程中，一般推荐使用长连接，因为可以减少建连和断连的过程，但是长连接过多可能会导致MySQL系统高负载，导致服务异常重启。 长连接长期不释放，MySQL系统内存会占用很大，如何解决？ 一般来说，有以下几种解决方式： 设置合理的超时时间在MySQL服务器和客户端之间建立长连接时，可以设置合理的超时时间。通过配置wait_timeout和interactive_timeout参数，可以控制连接在闲置一段时间后自动关闭。这样可以确保长时间不活跃的连接被释放，释放相关的资源。 使用连接池使用连接池管理连接是一种常见的解决方案。连接池可以维护一组预先创建的连接，并在需要时分配给客户端。连接池会复用连接，避免频繁地创建和销毁连接，从而减少资源消耗。连接池通常还提供连接的管理和监控功能，可以根据需求配置连接的最大数量、超时时间等参数。 显式关闭连接在编写应用程序代码时，确保在不再需要连接时显式关闭连","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"查询缓存 建立连接之后，客户端就可以向MySQL服务器发送执行SQL了，MySQL服务器收到SQL语句后首先判断这个SQL语句是不是查询语句（根据SQL语句第一个字段是不select来判断），如果是查询语句的话，MySQL就会先去查询缓存里面查找是否有这个SQL查询语句的缓存结果，如果有的话，直接就返回给客户端，不进行下一步，缓存是以key:value形式存储的，key是SQL查询语句，value是查询结果。 看起来很美好，但是需要关注一下这里的缓存命中以及有效率的问题，在一般情况下，MySQL的查询缓存失效率是很高的，因为只要MySQL表中有数据更新，缓存就会失效。比如我要查询 select * from student where id=1; 第一次查询这条记录后，MySQL会把id=1的查询结果刷到缓存中，但是如果MySQL执行了更新语句，这个缓存就会失效。 比如MySQL更新了id=2的数据 update student set name='张三' where id=2; 我们可能会在想，为啥MySQL做的这么粗暴呢，更新id=2不影响id=1的结果啊，为啥要把id=1的缓存干掉？因为MySQL不知道更新id=2这条记录是否会影响id=1的这条记录，或者说想要知道是否会影响的代价太大了(很难判断是否会有影响，如果真要判断，付出的代价相比于缓存的收益更大，得不偿失)，MySQL为了保证数据的一致性，干脆只要一有更新操作就让缓存失效。 从上面的分析可以知道，这个缓存好像没啥用，因为即便是读多写的场景，也不能完全不写，而只要有写操作，就让表的所有缓存失效，代价是很大的，成本和收益不成正比，所以在MySQL8.0的版本，去掉了查询缓存这个功能。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"解析器 一条SQL语句如果能够执行成功，首先肯定是符合MySQL的SQL语法规范的，这个规范可以理解为我们和MySQL定的规则，我们遵循这个规则来写SQL语句，MySQL同样也要遵循规则去解析执行我们写的SQL语句，不可能说我们随便写一段字符串，MySQL也去给我们执行。在执行SQL语句之前，MySQL需要理解我们这条SQL语句是干嘛的，是增、删、改还是查，SQL语句涉及到哪些表，哪些表字段？这些都需要也可以根据语法规则去提取出来的，这实际上就是解析器要做的事。 解析器会做两件事： 第一件事： 语法分析MySQL会根据和我们协定的语法规则检查SQL语句是否有语法错误，如果有语法错误，会直接报错You have an error in your SQL syntax,比如我们执行如下语句 mysql\u003e slect * from friend where id=1; ERROR 2013 (HY000): Lost connection to MySQL server during query No connection. Trying to reconnect... Connection id: 10788396 Current database: mysql_learn ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'slect * from friend where id=1' at line 1 mysql\u003e 把select打成了slect，MySQL根据语法规则校验这条SQL语句是不符合语法规范的，就直接报错了。这个类似于我们后台开发常用的参数校验。 第二件事： 词法分析：不管是多复杂的SQL语句总是有规律可循的，比如where关键字后面肯定是查询条件，from关键字后面是表名， MySQL实现了词法解析器，根据SQL语句提取出来表名、SQL类型、表名、字段名，where查询条件等，做好准备工作给到后面模块使用。 需要注意的是上面说到语法检查和词法分析是在解析器做的，但是判断表名和字段名是否存在这些并不是在解析器层做的，可以理解为解析器这一层都是本地逻辑，不涉及到网络或者API调用。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"预处理器 SQL语句经过解析器后，就可以判断这条SQL语句是可能可以被执行的，为什么是可能呢？因为经过解析器只能说明这条SQL语句语法是没问题的以及提取了表名等需要执行的SQL语句包含的关键信息，但并不代表这个SQL语句就一定能执行成功，就像上面说的，如果SQL语句查询一张不存在的表，那么肯定不会执行成功的。预处理器主要干两件事： 检查解析器从SQL语句中提取出来的表名、字段名是否存在。 将select *的*替换成实际的字段名 这一步就不像解析器那样是纯本地逻辑的，在预处理阶段，需要先读取表的信息，进而检查表名、字段名是否存在，以及将 *替换成实际的字段名，这就涉及到API调用了。 我们执行如下SQL语句报错，这个报错其实是预处理器返回的。 mysql\u003e select * from frined where id=1; ERROR 1146 (42S02): Table 'mysql_learn.frined' doesn't exist mysql\u003e ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"优化器 经过解析器和预处理器后，SQL语句来到了优化器，严格来说，到了优化器，不能再叫SQL语句了，因为经过前面两位大哥的处理之后，SQL语句已经面目全非，到了优化器这一层，可以确定这条SQL语法是完全合法的，既没有语法错误，表名和字段名也都存在。那为啥还要经过优化器处理，直接丢给执行器执行不就行了吗？肯定不行，如果这么无脑的话，那MySQL估计没人用了。优化器会根据SQL语句以及当前表的实际数据情况等选择一个合适的执行方案，比如一条SQL查询语句有多个索引，优化器就要分析判断使用哪个索引查询代价更小，又比如如果表里的数据量很小的时候，全表扫描代价可能更小，优化器可能会选择全表扫描而不选择使用索引。 回顾一下我们经常使用的explain命令，在select前面加上explain关键字就可以知道本次查询执行计划。 查询语句一 mysql\u003e explain select * from `like` where id=1; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | like | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.04 sec) mysql\u003e 查询语句二 mysql\u003e explain select * from `like` limit 1; +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ | 1 | SIMPLE | like | NULL | index | NULL | uk_user_id_liker_id | 8 | NULL | 3 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.03 sec) mysql\u003e 可以看到两次查询key这一列都不为空，查询语句一MySQL选择了PRIMARY主键索引，查询语句二则选择使用了uk_user_id_liker_id唯一索引，如果key为空，则代表没有使用索引，而是使用了全表扫描。 在实际开发中，一摸一样的SQL语句，在不同时刻执行执行计划可能会不一样，执行计划取决于很多因素，包括索引、表数据量大小等。总而言之MySQL会根据很多条件选择一种相对最优的执行计划减少SQL语句执行成本。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:5","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"执行器 经过前面的\"前戏\"后，终于要进入正题了，正式执行SQL语句了，执行器说白了就是MySQL的Server层和存储引擎层的一个桥梁，执行器并不实际执行SQL语句，而是通过API接口把经过一系列处理后的\"SQL语句\"丢给存储引擎执行，等待存储引擎返回执行结果，再把执行结果返回给查询缓存以及连接器。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:6","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"小结 总结一条SQL语句从客户端发起到客户端收到执行结果的过程 客户端经过连接器和MySQL服务端建立连接，连接器会校验用户名及密码是否正确，以及确定用户的权限，并存储用户的权限在内存中，在本次连接的生命周期中，用户的权限是一致的。 建立连接之后，请求来到了解析器，解析器主要干两件事：校验SQL语句是否符合语法规范，有语法错误直接报错；提取 SQL语句的关键字、表名、表字段关键信息。 经过解析器校验语法和提取关键信息后，请求到了预处理器，预处理器主要是确认SQL语句的表名字段名是否存在如果不存在直接报错，以及将 *关键字替换成实际的表字段。 经过上述检查和处理，就表示这条SQL语句是可执行的，但是在执行之前，服务端需要分析判断索引、当前数据表数据情况优化SQL语句执行，选择一个相对最优的方式去执行。 执行器收到优化器优化后的SQL语句，将SQL语句丢给存储引擎，然后等待执行结果将结果返回给执行器和查询缓存。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:7","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"索引 上述详细阐述了一条SQL语句从客户端到执行器丢给存储引擎整个流程，以上都是在MySQL的服务层实现的与存储引擎无关。本节主要介绍InnoDB存储引擎的索引概念和底层实现以及具体应用。 说到索引，首先要明确一下在MySQL中有哪些索引，根据不同维度划分，有以下几类索引 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"数据结构划分 索引类型\\存储引擎 InnoDB MyISAM Memory B+Tree Yes Yes Yes HASH No,会有自适应hash，存储引擎自动实现，没法指定。 No Yes Full-Text Yes Yes No InnoDB是MySQL默认的存储引擎，实际业务开发中，也比较推荐使用InnoDB，InnoDB事实上成了默认标准了 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"物理存储划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"字段特征划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"字段个数划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"三大日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"undo日志 undo日志是innodb引擎实现的一个 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"redo日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"bin日志 bin日志是mysql服务层实现的用于数据持久化的一种日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"各种锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"表级锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"行锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"间隙锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"临键锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"插入意向锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:5","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"自增锁 自增锁（Auto-Increment Lock）主要用于生成自增主键ID。在InnoDB中，当一张表的主键列设置为自增（AUTO_INCREMENT）时，每次插入新记录时，主键列的值会自动递增。自增锁确保在同一时间只有一个事务能够获取自增列的下一个值，避免在高并发场景下出现主键ID重复的问题。 当一个事务需要插入一条新记录时，它会请求自增锁，获取自增列的下一个值作为主键ID。在事务完成插入操作并释放自增锁之前，其他试图插入新记录的事务需要等待。这样，自增锁可以确保主键ID的唯一性，避免数据不一致的问题。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:6","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"事务 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"原子性 底层实现 一组操作要么都成功要么都失败，称之为原子性。设想一个场景，我现在有一个多写逻辑，有A、B、C三个步骤，A和B都成功了，C失败了，这个时候需要回滚数据恢复到这个逻辑之前，也就是要撤销A和B，这就要求我们需要知道被A和B修改成功的数据被修改之前的原始数据，然后用这个原始数据回滚，所以需要有一个地方记录被修改之前的原始数据。在Innodb中，这个存储被修改数据在修改之前的数据就是undo日志，也就是说，innodb的事务原子性是通过undo日志实现的。具体过程如下： Undo日志实现原子性 修改一行或多行数据，会在这个事务的update undo log链表中插入修改之前的数据，使用头插法按照修改的顺序插入数据，这些数据是按照修改的顺序逆序存储的，也就是说，最后修改的数据会被放在链表的最前面。 插入/删除一行或多行数据，会在这个事务的insert undo log链表中记录被插入/删除数据的主键id，使用头插法按照修改的顺序插入主键ID，这些ID也是按照插入的顺序逆序存储的，也就是说，最后插入的数据的ID会被放在链表的最前面。 如果事务执行失败或者被回滚，InnoDB会遍历上述日志链表，按照顺序执行回滚操作，以此来撤销事务中的所有修改。 小结 innodb借助undo日志实现事务的原子性，具体做法的在每次更新或者插入/删除数据之前先备份一下当前数据到undo日志链表中，当事务回滚的时候就可以遍历执行unlo日志链表达到回滚数据的目的 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"持久性 底层实现 持久性要求在数据库发生崩溃（如宕机、拔电源的时候，数据也能够保证不丢失。确保数据库从宕机等状态恢复的时候能够从磁盘中恢复尚未写到binlog的日志。和unro日志记录修改之前的数据不一样，redo日志是记录被修改后的数据，当数据库发生崩溃重启的时候，会根据unlo日志回滚尚未提交成功的事务。然后根据redo日志重放事务。 假设现在有两个事务，A事务执行到一半，B事务执行完成并提交，系统崩溃宕机，系统重启后，redo日志重放B事务并提交，undo日志回滚A事务。这就是InnoDB如何使用Undo日志和Redo日志来恢复系统状态的。通过这两种日志，InnoDB可以确保在系统崩溃后，所有已提交的事务的修改都不会丢失，所有未提交的事务的修改都可以被撤销，从而保证了数据库的一致性和持久性。 每次当一个事务进行修改操作时，InnoDB会生成相应的Redo日志，这个Redo日志有一个LSN，这是一个递增的数字，用来标识每个Redo日志的唯一性。同时，每个数据页在内存中也有一个LSN，表示这个数据页到哪个点被修改过。当这个Redo日志被应用到数据页时，也就是数据页被修改时，数据页的LSN会被更新为这个Redo日志的LSN。这样，数据页的LSN就表示了这个数据页被修改的最后一次操作。在重放过程中，InnoDB会比较Redo日志的LSN和数据页的LSN，只有当Redo日志的LSN大于数据页的LSN时，才会重放这个日志，也就是说，只有当Redo日志中的修改还没有被应用到数据页时，才会重放这个日志，所以在回放的时候并不是无脑回放所有的redo日志，而是会判断lsn丢弃掉已经持久化数据到数据页的redo日志，避免数据重复写入到数据页。mysql使用两阶段提交保证redo log和bin log的一致性，简单来说才数据写入bin log的时候会先写redo 日志，此时redo日志的状态为prepare，写redo日志成功后继续写bin log，bin log写成功后最后再把redo log的状态从prepare 改为commit。两阶段提交的目的是为了保证主库和从库数据的一致性，在事务崩溃的时候借助redo日志，可以恢复本机的数据页的数据，但是主从同步是借助bin log完成的，如果没有两阶段提交，可能会导致主库和从库的数据不一致。 两阶段提交保证binlog数据和本机数据一致性 小结 持久性依赖于undo和redo日志，每次事务提交的时候就会把redo日志落盘，当系统崩溃恢复的时候，会进入redo阶段回放日志，redo阶段的目的是为了将成功提交但还没持久化到数据页的那部分事务进行回放恢复；redo回放完成后进入到undo阶段，undo阶段的目的是将因系统崩溃导致未提交的事务的数据进行回滚避免脏数据。在redo阶段和undo阶段期间会阻塞所有写请求直到重放和恢复完成，这是为了确保数据库在恢复过程中保持一致性，避免在恢复过程中产生新的错误或不一致；而对于读请求则视事务的隔离级别以及数据库系统的配置而定。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"隔离性 在mysql中有四种隔离级别，按照隔离程度分别是读未提交、读已提交、可重复读、串行化。所谓隔离性指的是多事务之间是隔离的，互相不干扰，抛开事务来看，我们日常写业务代码的时候，涉及到对多个线程共享的数据进行读写的时候，为了保证数据的安全性，一般会对共享数据进行加锁，其实这个“加锁”就是mysql中的最高隔离级别串行化。在mysql中为了兼顾性能和数据一致性，提供了不同的隔离级别，业务可以根据自己实际使用情况选用不同的隔离级别。 读未提交 最低的一种隔离级别，在事务中读到的数据永远是当前数据库最新的数据，在一个事务执行过程中，如果有其它事务对该事务读取的数据进行修改，可以读到其它事务修改但还未提交的数据。可以把它类比于多线程对共享数据进行读写，但不做任何并发保护，可能会导致读到很奇怪的数据，甚至读到修改一半的数据。读未提交因为是最低的隔离级别，性能自然也是最好的，因为不需要任何手段保护数据，但是数据一致性也是最差的。读未提交可能会导致脏读(读到其它事务更新但又回滚的数据)、不可重复读（多次读同一条数据结果不一样）幻读（多次读同一个范围内的数据返回的结果少了或者多了数据）。读未提交适用于对性能要求比较高，但是对于数据一致性要求稍弱的场景，比如实时数据分析、缓存预热、非关键业务数据查询 读已提交 可以读到其它事务提交的数据，底层使用mvcc+redo实现，每次查询的时候都会开启一个快照，获取当前还没提交的事务ID列表，下一个事务ID是上述列表中最大事务ID+1，判断读到的数据的的事务ID是否在这个还未提交的事务ID列表中以及是否是下一个事务ID，如果不在的话，就认为数据是可信的，直接返回，否则的话会沿着回滚链表指针向后遍历直到找到可信的数据。因为每次查询都会开启一个快照，所以如果第一次快照里面的某些事务在第二次开启快照的时候提交了，第二次开启快照的时候未提交事务ID列表就没有第一次和第二次快照这个时间区间内的事务（因为已经提交了），所以会读到本事务执行期间其它已经成功提交的事务的数据，所以会造成不可重复读。在读已提交这个隔离级别，只有行锁和表锁起作用。 可重复读 实现和读已提交类似，区别在于rr隔离级别会在事务启动的时候开启一个全局快照，而不是像读已提交每次都会开启一个快照，也就是说rr级别下，整个事务周期中其它未提交事务ID列表和下一个事务ID是保持不变的，这样的好处在于其它事务提交的数据跟我无关，在快照读的情况下可以避免不可重复读和幻读的问题。但是需要注意的是，对于当前读（如 select .. for update /update /delete等语句）会读到当前的最新数据，对于当前读，rr会使用next-key lock+行锁来尽量保证避免出现幻读的问题，但是不能百分之百保证幻读，典型的如下两个例子。⚠️：幻读在rr隔离级别下只会出现在当前读这个场景，对于普通读是没有影响的。 case1 begin select name from user where id=2; # user表中不存在id=2这条数据，读出来是空 #....在这个区间内另一个事务执行 insert into user (id,name) values(2,\"lisi\")并成功提交 update user set name='zhangsan' where id=2; # 因为此时user表中有id=2这条数据，update会当前读，所以这条数据成功更新了 select name from user where id=2; # user表中存在id=2这条数据，并且是由本事务更新的，所以读出来这条数据是 `zhangsan` commit # 在以上事务执行过程中，出现一模一样的sql执行语句两次执行结果不一样，出现了幻读，由于update是当前读会更新表中的数据，第二次读的时候发现表中隐藏列的指针代表的版本是本事务修改的，所以认为数据是可信的，返回结果。 case2 begin select * from user where id\u003e3; # 此时有表中有三条数据 id 分别为4、5、6 #....在这个区间内另一个事务执行 insert into user (id,name) values(7,\"lisi\")并成功提交 select * from user where id\u003e3 for update; # 因为for update 是当前读，并且由于第一次读是快照读不回上写锁，所以本次读会读出四条数据，id 分别为 4、5、6、7 commit # 两次读的数据不一样，出现了幻读，原因在于第一个select语句是快照读只会加读锁不回加写锁，也就是说阻止不了其他事务插入删除或者更新数据，而刚好第二次读是当前读，读到的最新的数据，导致了两次读取数据不一样。但是如果把两个语句换个顺序就不会出现幻读的问题了，因为for update会加next-key lock(gap 锁+行锁)，会锁住数据其他事务在本事务提交之前是不能进行增、删、改的操作 begin select * from user where id\u003e3 for update; # 此时有表中有三条数据 id 分别为4、5、6，会加间隙锁[4,+∞),直到本事务提交才释放 select * from user where id\u003e3; # 因为第一次select加锁了，所以本次读出来的数据和第一次一样，不会出现幻读。 commit 串行化 最高的一种隔离级别，类似于加读写锁，同一时刻只有一个事务在执行，类似于单线程的方式。这种隔离级别下不回出现以上三种隔离级别的问题，但是性能也是最差的。一般用在对于数据一致性要求极高的场景，如银行、金融等领域。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"一致性 上述疏导的原子性、隔离性、持久性，都是手段，一致性才是目的，换句话说mysq实现了原子性、持久性、隔离性保证数据的一致性。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"数据结构 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:6:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"内存","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:7:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"对于reactor的一点理解","date":"2023-07-01","objectID":"https://www.bardblog.cn/reactor-pattern/","tags":["IO","Reactor","Redis","Kafka"],"title":"Reactor模式","uri":"https://www.bardblog.cn/reactor-pattern/"},{"categories":["technology"],"content":"介绍git的一些不太常见的高级用法","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"Git 子模块 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:0","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"概念 Git 子模块允许你将另一个 Git 仓库作为主仓库的子目录引入。每个子模块都是一个独立的 Git 项目，具有自己的提交、拉取和推送操作。主仓库以子模块的形式包含多个子仓库。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:1","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"示例 我们通过一个示例来了解如何使用 Git 子模块。 创建一个名为 “gitSubmodules” 的文件夹，并将其初始化为 Git 仓库： mkdir gitSubmodules cd gitSubmodules git init 添加一个远程 origin，并将仓库推送到 GitHub： git remote add origin git@github.com:你的用户名/gitSubmodules.git echo \"关于 gitSubmodules\" \u003e\u003e README.md git add . git commit -m \"初始化 gitSubmodules\" git push --set-upstream origin main 在这里，将 “你的用户名” 替换为你的 GitHub 用户名。 现在，让我们将两个子仓库添加到 “gitSubmodules” 仓库中： git submodule add git@github.com:你的用户名/submodule1.git git submodule add git@github.com:你的用户名/submodule2.git 执行这些命令后，“gitSubmodules” 仓库将添加子模块 “submodule1” 和 “submodule2”。此命令会将子模块的远程仓库克隆到 “gitSubmodules” 仓库的根目录中。 默认情况下，每个子模块将被放置在与子仓库同名的目录中。 如果你执行 git status 命令，你将看到仓库中现在有一个名为 “.gitmodules” 的文件，以及两个名为 “submodule1” 和 “submodule2” 的目录。 “.gitmodules” 文件存储了子模块的本地目录路径与远程仓库 URL 之间的映射关系。 提交并推送更改到主仓库： git add . git commit -m \"添加 submodule1 和 submodule2 子模块\" git push 这将把子模块的信息一并推送到远程仓库。 如果有人克隆了 “gitSubmodules” 仓库，他们最初会得到子模块的空目录。为了将子模块填充为其相应的内容，他们需要运行以下命令： git submodule init git submodule update 运行这些命令后，子模块的远程文件将与本地仓库同步，包括每个子模块的提交信息。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:2","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"使用场景 Git 子模块在需要在主项目中引入其他项目时非常有用,每个项目可以拥有自己独立的仓库和版本控制历史，确保对主项目和子模块的修改互不干扰。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:3","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":null,"content":"About Bard","date":"2023-06-24","objectID":"https://www.bardblog.cn/about/","tags":null,"title":"About Bard","uri":"https://www.bardblog.cn/about/"},{"categories":null,"content":"英文名：BardChen 地点：深圳 职业：程序员 运动：跑步、羽毛球、爬山 博客源码：https://github.com/YourFantasy/blog 博客理念：记录生活、记录成长。 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/about/:0:0","tags":null,"title":"About Bard","uri":"https://www.bardblog.cn/about/"}]