[{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"我的网站\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"这是我的全新 Hugo 网站\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"我的网站\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtu","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 繁體中文 zh-tw zh-TW 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi 阿拉伯语 ar ar 加泰罗尼亚语 ca ca 泰语 th th 泰卢固语 te te 印尼语 id id 土耳其语 tr tr 韩语 ko ko 印地语 hi hi ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" [[languages.en.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[languages.en.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" languageCode = \"zh-CN\" languageName = \"简体中文\" hasCJKLanguage = true [[languages.zh-cn.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" [[languages.fr.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" [[languages.fr.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. 官方提供的 Algolia CLI 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"https://www.bardblog.cn/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"https://www.bardblog.cn/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" license: \"\" images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true rssFullText: false toc: enable: true auto: true code: copy: true maxShownLines: 50 math: enable: false # ... mapbox: # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $\\KaTeX$ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. $\\KaTeX$ 根据 特定的分隔符 来自动渲染公式. 技巧 有一份 $\\KaTeX$ 中支持的 $\\TeX$ 函数 清单. 注意 由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染: _ -\u003e \\_ * -\u003e \\* \u003e\u003e -\u003e \\\u003e\u003e \\( -\u003e \\\\( \\) -\u003e \\\\) \\[ -\u003e \\\\[ \\] -\u003e \\\\] \\\\ -\u003e \\\\\\\\ LoveIt 主题支持 raw shortcode 以避免这些转义字符, 它可以帮助您编写原始数学公式内容. 一个 raw 示例: 行内公式: 公式块: 呈现的输出效果如下: 行内公式: 公式块: 行内公式 默认的行内公式分割符有: $ ... $ \\( ... \\) (转义的: \\\\( ... \\\\)) 例如: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\\\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\\\) 呈现的输出效果如下: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 公式块 默认的公式块分割符有: $$ ... $$ \\[ ... \\] (转义的: \\\\[ ... \\\\]) \\begin{equation} ... \\end{equation} (不编号的: \\begin{equation*} ... \\end{equation*}) \\begin{align} ... \\end{align} (不编号的: \\begin{align*} ... \\end{align*}) \\begin{alignat} ... \\end{alignat} (不编号的: \\begin{alignat*} ... \\end{alignat*}) \\begin{gather} ... \\end{gather} (不编号的: \\begin{gather*} ... \\end{gather*}) \\begin{CD} ... \\end{CD} 例如: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}\\_{i}=\\mathbf{E}\\_{1}+\\mathbf{E}\\_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\\\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\\\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\\\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\\\u003e\u003e B \\\\\\\\ @VbVV @AAcA \\\\\\\\ C @= D \\end{CD} 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} 技巧 你可以在 网站配置 中自定义行内公式和公式块的分割符. Copy-tex Copy-tex 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 在选择并复制 $\\KaTeX$ 渲染的公式时, 会将其 $\\LaTeX$ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 $\\LaTeX$ 源代码. mhchem mhchem 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"https://www.bardblog.cn/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"https://www.bardblog.cn/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram instagram 的文档 Instagram’s API was deprecated since October 24th, 2020 The instagram-shortcode refers an endpoint of Instagram’s API, that’s deprecated since October 24th, 2020. Thus, no images can be fetched from this API endpoint, resulting in an error when the instagram-shortcode is used. For more information please have a look at GitHub issue #7879. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 917359331535966209 \u003e}} 呈现的输出效果如下: Reminder: This Twitter account is not actively maintained for questions. Please post all questions on https://t.co/yAzbBojxaU #gohugo — GoHugo.io (@GoHugoIO) October 9, 2017 ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-built-in-shortcodes/"},{"categories":["technology"],"content":"深度优先搜索解决连通块问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"题目描述 给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数 n，表示树的结点数。 接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。 输出格式 输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。 数据范围 1≤n≤105 输入样例: 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:1:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"实现思路 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:2:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码实现 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:0","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码1 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) son := make(map[int]*listNode) used := make([]bool, n+1) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 2000*1000) scanner.Buffer(buf, len(buf)) for i := 0; i \u003c n-1; i++ { scanner.Scan() ss := strings.Split(scanner.Text(), \" \") var a, b int a, _ = strconv.Atoi(ss[0]) b, _ = strconv.Atoi(ss[1]) add1(son, used, a, b) } res := n dfs1(son, n, 1, \u0026res, make([]bool, n+1)) fmt.Println(res) } func dfs1(mp map[int]*listNode, n, t int, res *int, visited []bool) int { visited[t] = true tmp := 0 sum := 1 for h := mp[t]; h != nil; h = h.next { if !visited[h.val] { s := dfs1(mp, n, h.val, res, visited) tmp = max(tmp, s) sum += s } } tmp = max(tmp, n-sum) *res = min(*res, tmp) return sum } func max(a, b int) int { if a \u003c b { return b } return a } func min(a, b int) int { if a \u003c b { return a } return b } // add 构造图 // son，存储编号为k的节点的孩子节点 // used 编号为b的节点是否曾经是某个节点的孩子节点,是否被用作过孩子节点 // 因为同一个节点只能是一个节点的孩子节点，所以如果b节点之前为某个节点的孩子节点，那么此时b节点是a节点的父节点，a节点是b节点的孩子节点 func add1(son map[int]*listNode, used []bool, a, b int) { if !used[b] { newNode := \u0026listNode{val: b, next: son[a]} son[a] = newNode used[b] = true } else { newNode := \u0026listNode{val: a, next: son[b]} son[b] = newNode } } type listNode struct { val int next *listNode } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:1","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"代码2 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) h, c, ne := make([]int, n+1), make([]int, 2*n+1), make([]int, 2*n+1) for i := 0; i \u003c= n; i++ { h[i] = -1 } idx := 0 visited := make([]bool, n+1) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 20000*1000) scanner.Buffer(buf, len(buf)) for i := 0; i \u003c n-1; i++ { scanner.Scan() s := scanner.Text() ss := strings.Split(s, \" \") var a, b int a, _ = strconv.Atoi(ss[0]) b, _ = strconv.Atoi(ss[1]) add2(h, c, ne, a, b, \u0026idx) add2(h, c, ne, b, a, \u0026idx) } res := n dfs2(h, c, ne, n, 1, visited, \u0026res) fmt.Println(res) } func dfs2(h, c, ne []int, n, t int, visited []bool, res *int) int { visited[t] = true sum := 1 tmp := 0 for i := h[t]; i != -1; i = ne[i] { if !visited[c[i]] { s := dfs2(h, c, ne, n, c[i], visited, res) sum += s tmp = max(tmp, s) } } tmp = max(tmp, n-sum) *res = min(*res, tmp) return sum } // 建立连接图 // 参考https://www.acwing.com/file_system/file/content/whole/index/content/4446359/ func add2(h, c, ne []int, p, s int, idx *int) { c[*idx] = s ne[*idx] = h[p] h[p] = *idx *idx += 1 } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-dfs-acwing-846/:3:2","tags":["algorithm","bfs"],"title":"连通块点数最大值","uri":"https://www.bardblog.cn/algorithm-dfs-acwing-846/"},{"categories":["technology"],"content":"bfs解决最短路问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"题目描述 给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。 输入格式 第一行包含两个整数 n 和 m。 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤100 输入样例： 5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出样例： 8 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:1:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"实现思路 典型的最短路问题，遍历从起始到终点的路径，记录最小值。 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:2:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"代码实现 package main import \"fmt\" const N = 101 func main() { var n, m int fmt.Scanf(\"%d%d\", \u0026n, \u0026m) nums := make([][]int, n) d := make([][]int, n) for i := 0; i \u003c n; i++ { nums[i] = make([]int, m) d[i] = make([]int, m) for j := 0; j \u003c m; j++ { var tmp int fmt.Scanf(\"%d\", \u0026tmp) nums[i][j] = tmp d[i][j] = -1 } } fmt.Println(bfs(nums, d, newQueue(N*N))) } func bfs(nums, d [][]int, q *queue) int { n, m := len(nums), len(nums[0]) d[0][0] = 0 dx := [4]int{-1, 0, 1, 0} dy := [4]int{0, 1, 0, -1} q.push(\u0026pair{0, 0}) for !q.isEmpty() { t := q.pop() for i := 0; i \u003c 4; i++ { // 上下左右四个方向寻找 x, y := t.x+dx[i], t.y+dy[i] // 当前位置的下一个位置 if x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 nums[x][y] == 0 \u0026\u0026 d[x][y] == -1 { d[x][y] = d[t.x][t.y] + 1 q.push(\u0026pair{x, y}) } } } return d[n-1][m-1] } type pair struct { x int y int } type queue struct { elements []*pair begin int end int } func newQueue(n int) *queue { return \u0026queue{ elements: make([]*pair, n), begin: 0, end: -1, } } func (q *queue) push(p *pair) { q.end += 1 q.elements[q.end] = p } func (q *queue) pop() *pair { res := q.elements[q.begin] q.elements[q.begin] = nil q.begin += 1 return res } func (q *queue) isEmpty() bool { return q.end \u003c q.begin } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-bfs-acwing-844/:3:0","tags":["algorithm","bfs"],"title":"迷宫最小的移动次数","uri":"https://www.bardblog.cn/algorithm-bfs-acwing-844/"},{"categories":["technology"],"content":"三种工厂模式","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"工厂模式大致可分为 简单工厂模式 工厂方法模式 抽象工厂模式 下面就这三种工厂模式做一下介绍并配上实现代码 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:0:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"简单工厂模式 简单工厂模式，也叫静态方法模式，在对象创建工厂类中定义了一个静态方法来创建对象，简单工厂设计模式让客户端（使用者）无需知道对象的具体细节就能创建出所需的产品实例，使用者可以直接使用生产出来的对象而无需关心对象是如何生产出来的。 类图： 简单工厂模式 代码： package main import \"fmt\" type Animal interface { eat() weight() int } type Dog struct { } func (d *Dog) eat() { fmt.Println(\"dog eat !\") } func (d *Dog) weight() int { return 30 } type Cat struct { } func (c *Cat) eat() { fmt.Println(\"cat eat!\") } func (c *Cat) weight() int { return 10 } type AnimalFactory struct { } func (a *AnimalFactory) newAnimal(animalType int) Animal { switch animalType { case 0: return \u0026Dog{} case 1: return \u0026Cat{} default: return nil } } func main() { factory := new(AnimalFactory) dog := factory.newAnimal(0) dog.eat() fmt.Println(dog.weight()) cat := factory.newAnimal(1) cat.eat() fmt.Println(cat.weight()) } 可以看到简单工厂模式还是挺简单的，实现了将创建实例和使用实例分离，使用者无需关心实例创建过程，实现了分离解耦，无需知道被创建对象的详细信息，只需要知道该对象对应的类型映射即可。那么简单工厂模式有什么缺点呢？在生产对象的时候，根据传入的animal类型来确定创建哪个具体的动物对象，当我们增加更多的annimal种类的时候，比如增加兔子、大象等animal，随着动物种类的越来越多，newAnimal方法就会不断膨胀，并且每次动物种类发生变动的时候，都要去修改这部分代码，不符合开闭原则。 那么如何解决上述问题呢？其实也不能说解决，只能算一个编程小技巧，可以发现newAnimal方法大量的swich case，每次如何干掉这些swich case呢？在main函数中，当我们需要创建某个具体动物对象的时候，需要传入animalType字段然后调用newAnimal方法创建对象，也就是说，我们需要用到某个动物对象的时候才去创建，是一种“懒加载思想”;如果我们每次增加一个新的动物的时候，就创建该动物的实例，然后放到一个map字典中，在要用到该动物的时候，直接从map中取，不就不用维护一个newAnimal方法吗？其实就是把“懒加载思想”转化为“饿加载思想”，不管你用不用我这个对象，我这个对象既然存在，不管三七二十一，就创建一个对象实例塞到map字典里面再说。代码可以改为如下这样： 代码： package main import \"fmt\" // 饿加载，注册到map工厂 func init() { Register(0, \u0026Dog{}) Register(1, \u0026Cat{}) } type Animal interface { eat() weight() int } type Dog struct { } func (d *Dog) eat() { fmt.Println(\"dog eat !\") } func (d *Dog) weight() int { return 30 } type Cat struct { } func (c *Cat) eat() { fmt.Println(\"cat eat!\") } func (c *Cat) weight() int { return 10 } type AnimalFactory struct { } func Register(animalType int, animal Animal) { animals[animalType] = animal } func Get(animalType int) Animal { a, ok := animals[animalType] if !ok { return nil } return a } var animals = make(map[int]Animal) // animal type =\u003e Animal func main() { dog := Get(0) dog.eat() fmt.Println(dog.weight()) cat := Get(1) cat.eat() fmt.Println(cat.weight()) } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:1:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"工厂方法模式 工厂方法模式也叫多态工厂模式，前面介绍了一下简单工厂模式，动物创建工厂无论什么Dog还是Cat都在同一个动物工厂生产，每次需要增加新的动物种类的时候，动物工厂都需要作出相应的改变。就好比，每次生产一个新的动物物种，都需要增加相应的配套工具，这对于系统的扩展性不是很好。工厂方法模式可以看作是对简单工厂模式的一种升级，即不同种类的动物不再在同一个动物工厂生产了，而是进行了细分，每种类型的动物都有一个专门的动物工厂进行生产，这里以汽车作为例子。 类图： 工厂方法模式 代码： package main import \"fmt\" // Car 汽车抽象接口，定义car的两个行为，开车和加油 type Car interface { drive() oil(cnt int) } // Bmw 宝马汽车 type Bmw struct { } func (b *Bmw) drive() { fmt.Println(\"i drive bmw!\") } func (b *Bmw) oil(cnt int) { fmt.Println(\"bmw add \", cnt, \" oil\") } // Benz 奔驰汽车 type Benz struct { } func (b *Benz) drive() { fmt.Println(\"i drive benz!\") } func (b *Benz) oil(cnt int) { fmt.Println(\"benz add \", cnt, \" oil\") } // CarFactory 汽车工厂接口，生产汽车 type CarFactory interface { makeCar() Car } // BmwFactory 宝马汽车工厂，生产宝马汽车 type BmwFactory struct { } func (b *BmwFactory) makeCar() Car { return new(Bmw) } // BenzFactory 奔驰汽车工厂，生产奔驰汽车 type BenzFactory struct { } func (b *BenzFactory) makeCar() Car { return new(Benz) } func main() { bmwFactory := new(BmwFactory) bmw := bmwFactory.makeCar() bmw.drive() bmw.oil(1) benzFactory := new(BenzFactory) benz := benzFactory.makeCar() benz.drive() benz.oil(2) } 简单总结一下工厂方法模式的优缺点： 优点： 1.可扩展性好，当需要增加一款新的产品时（如添加奥迪汽车），无需修改抽象工厂和抽象工厂提供的接口，祝需要添加一个具体工厂和具体产品就行了，更加符合“开闭原则”，简单工厂模式则需要修改工厂类的判断逻辑， 2.符合单一职责原则：每个具体工厂类只负责生产对应的产品。简单工厂模式的工厂类还需要有一定逻辑判断 3.基于⼯⼚⻆⾊和产品⻆⾊的多态性设计是⼯⼚⽅法模式的关键。它能够使⼯⼚可以⾃主确定创建何种产品对象（该产品的工厂类只需要实现抽象工厂接口即可），⽽如何创建这个对象的细节则完全封装在具体⼯⼚内部。⼯⼚⽅法模式之所以⼜被称为多态⼯⼚模式，是因为所有的具体⼯⼚类都具有同⼀抽象⽗类。 缺点： 1.每次添加新的产品，都需要编写新的具体产品类，并且同时也要提供该产品对应的工厂类，当系统中产品数量表多的时候，类的个数会因此成倍增加，会在一定成都上导致系统的复杂性，并且多个类需要编译运行，会在一定程度上增加系统的开销 2.一个具体工厂类只能创建一种具体产品 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:2:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"抽象工厂模式 抽象工厂模式可以理解为生产工厂的工厂，即有一个超级工厂生产其他的工厂。马克思说过：“人是一切社会关系的总和”，一个人在社会上不可能只扮演一种角色，一个人的职业可能是程序员、也有其相应的家庭角色；同时程序员也有go、java、python程序员等，家庭角色也可能是是父亲、儿子、 丈夫等，共同构成了社会关系的总和。抽象工厂模式可以理解为简单工厂模式和工厂方法模式的结合体。自然也继承了各自的优缺点。 类图： 抽象工厂模式 代码： package main import \"fmt\" type programmer interface { writeCode() } type javaProgrammer struct { } func (j *javaProgrammer) writeCode() { fmt.Println(\"i am a java programmer,i write java\") } type goProgrammer struct { } func (g *goProgrammer) writeCode() { fmt.Println(\"i am a golang programmer,i write go\") } type family interface { love() } type father struct { } func (f *father) love() { fmt.Println(\"i am a father ,i love my wife and my son\") } type son struct { } func (s *son) love() { fmt.Println(\"i am a son ,i love my father and my mother\") } type programmerFactory struct { } func (p *programmerFactory) getProgrammer(programmerType int) programmer { switch programmerType { case 0: return new(javaProgrammer) case 1: return new(goProgrammer) default: return nil } } func (p *programmerFactory) getFamily(roleType int) family { return nil } type familyFactory struct { } func (f *familyFactory) getFamily(roleType int) family { switch roleType { case 0: return new(father) case 1: return new(son) default: return nil } } func (f *familyFactory) getProgrammer(programmerType int) programmer { return nil } type abstractHumanFactory interface { getFamily(roleType int) family getProgrammer(programmerType int) programmer } type factoryProducer struct { } func (*factoryProducer) getFactory(factoryType int) abstractHumanFactory { switch factoryType { case 0: return new(programmerFactory) case 1: return new(familyFactory) default: return nil } } func main() { fac := new(factoryProducer) programmerFac := fac.getFactory(0) java := programmerFac.getProgrammer(0) java.writeCode() golang := programmerFac.getProgrammer(1) golang.writeCode() familyFac := fac.getFactory(1) f := familyFac.getFamily(0) f.love() s := familyFac.getFamily(1) s.love() } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:3:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["technology"],"content":"小结 工厂模式作为最简单也最容易理解同时也是日常使用比较多的一个设计模式，大致可分为三种，在日常开发过程中，正确的使用设计模式能够极大的简化我们的代码，降低代码的耦合度，提升可维护性（毕竟是前人经验的总结），但切记千万不能滥用设计模式，使用不当可能会适得其反，千万不要为了使用设计模式而去使用设计模式！！！ ","date":"2023-06-24","objectID":"https://www.bardblog.cn/desigin-pattern-factory/:4:0","tags":["design-pattern"],"title":"设计模式之工厂模式","uri":"https://www.bardblog.cn/desigin-pattern-factory/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightGallery 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [可选] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. 完整文档请查看页面 主题文档 - mermaid Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts echarts shortcode 使用 ECharts 库提供数据可视化的功能. 完整文档请查看页面 主题文档 - echarts Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. 完整文档请查看页面 主题文档 - mapbox Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 完整文档请查看页面 主题文档 - music Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 完整文档请查看页面 主题文档 - bilibili Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 库提供了打字动画. 完整文档请查看页面 主题文档 - typeit Shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12 raw raw shortcode 用来在你的文章中插入原始  HTML 内容. 一个 raw 示例: 行内公式: {{\u003c raw \u003e}}\\(\\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots\\){{\u003c /raw \u003e}} 公式块: {{\u003c raw \u003e}} \\[ a=b+c \\\\ d+e=f \\] {{\u003c /raw \u003e}} 原始的带有 Markdown 语法的内容: {{\u003c raw \u003e}}**Hello**{{\u003c /raw \u003e}} 呈现的输出效果如下: 行内公式: 公式块: 原始的带有 Markdown 语法的内容: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:12:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"13 person person shortcode 用来在你的文章中以 h-card 的格式插入个人网站链接. person shortcode 有以下命名参数: url [必需] (第一个位置参数) URL of the personal page. name [必需] (第二个位置参数) Name of the person. text [可选] (第三个位置参数) Text to display as hover tooltip of the link. picture [可选] (第四个位置参数) A picture to use as person’s avatar. nick [可选] Nickame of the person. 一个 person 示例: {{\u003c person url=\"https://evgenykuznetsov.org\" name=\"Evgeny Kuznetsov\" nick=\"nekr0z\" text=\"author of this shortcode\" picture=\"https://evgenykuznetsov.org/img/avatar.jpg\" \u003e}} 呈现的输出效果为  Evgeny Kuznetsov (nekr0z). 一个使用通用图标的 person 示例: {{\u003c person \"https://www.bardblog.cn/\" Dillon \"author of the LoveIt theme\" \u003e}} 呈现的输出效果为  Dillon. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/:13:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"https://www.bardblog.cn/theme-documentation-extended-shortcodes/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"https://www.bardblog.cn/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"https://www.bardblog.cn/basic-markdown-syntax/"},{"categories":["technology"],"content":"贪心算法解决区间合并问题","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"题目描述 给定 N个闭区间 [ai,bi]，请你在数轴上选择若干个区间，使得选中的区间之间互不相交（包括端点）。 输出可选取区间的最大数量。 输入格式 第一行包含整数 N ，表示区间数。 接下来 N 行，每行包含两个整数 ai,bi ，表示一个区间的两个端点。 输出格式 输出一个整数，表示可选取区间的最大数量。 数据范围 1≤N≤105 , −109≤ai≤bi≤109 输入样例： 3 -1 1 2 4 3 5 输出样例： 2 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:1:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"代码实现 package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) func main() { var n int fmt.Scanf(\"%d\", \u0026n) scanner := bufio.NewScanner(os.Stdin) buf := make([]byte, 2000*1024) scanner.Buffer(buf, len(buf)) points := make([][]int, n) for i := 0; i \u003c n; i++ { scanner.Scan() strList := strings.Split(scanner.Text(), \" \") a, _ := strconv.Atoi(strList[0]) b, _ := strconv.Atoi(strList[1]) points[i] = []int{a, b} } sort.Slice(points, func(i, j int) bool { return points[i][1] \u003c points[j][1] }) cnt := 1 rightPoint := points[0][1] for i := 1; i \u003c n; i++ { if points[i][0] \u003e rightPoint { cnt++ rightPoint = points[i][1] } } fmt.Println(cnt) } ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:2:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["technology"],"content":"证明 先把原始区间按照右端点从小到大排序 对于第一个区间，选择右端点 从第二个区间开始，判断两个区间是否有交集，如果有交集，则合并两个区间（rightPoint是合并之前区间内最小右端点）；否则不相交区间+1 对于第k个区间，如果当前区间和前面所有区间（如果当前区间的左端点大于之前区间的最小右端点）都不相交， 不相交区间+1 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/algorithm-greedy-disjoint/:3:0","tags":["algorithm","greed"],"title":"最大不相交区间数量","uri":"https://www.bardblog.cn/algorithm-greedy-disjoint/"},{"categories":["documentation"],"content":"mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":" mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. mermaid 是一个可以帮助你在文章中绘制图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:5:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:6:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"实体关系图 一个 实体关系图 mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:7:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"用户体验旅程图 一个 用户体验旅程图 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:8:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:9:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"依赖图 一个 依赖图 mermaid 示例: {{\u003c mermaid \u003e}} requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/:10:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mermaid-shortcode/"},{"categories":["Markdown"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"表情与情感 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人与身体 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"动物与自然 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"活动 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"物品 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"符号 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"旗帜 ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["Markdown"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"https://www.bardblog.cn/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"https://www.bardblog.cn/emoji-support/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能. ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"https://www.bardblog.cn/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":" mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"https://www.bardblog.cn/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-music-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"https://www.bardblog.cn/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":" bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"https://www.bardblog.cn/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画.","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"https://www.bardblog.cn/theme-documentation-typeit-shortcode/"},{"categories":["technology"],"content":"负载均衡算法 在分布式系统中，一般来说会有多台机器，机器可能会分布在不同的集群，客户端的一个请求经过服务注册中心或者网关，注册中心或者网关会根据负载均衡算法将本次请求分发到某台具体的服务器，负载均衡算法主要用于分配网络或计算资源，以优化响应时间和避免过度负载任何一个资源常见的有如下的负载均衡算法： 负载均衡算法主要用于分配网络或计算资源，以优化响应时间和避免过度负载任何一个资源。以下是一些常见的负载均衡算法： 轮询（Round Robin）：这是最简单的负载均衡算法，它将请求按顺序分配给服务器。当到达最后一个服务器时，算法会返回到队列的顶部并重新开始。 加权轮询（Weighted Round Robin）：这是轮询的一个变种，它考虑到了服务器的处理能力。每个服务器都被分配一个权重，权重较高的服务器将接收更多的请求。 最少连接（Least Connections）：这种算法将新的请求分配给当前连接数最少的服务器。这对于处理时间较长的请求非常有效。 加权最少连接（Weighted Least Connections）：这是最少连接算法的一个变种，它考虑到了服务器的处理能力。每个服务器都被分配一个权重，权重较高的服务器将接收更多的请求。 随机（Random）：这种算法将请求随机分配给服务器。 最短响应时间（Least Response Time）：这种算法将请求分配给响应时间最短的服务器。 普通哈希（Hash）：这种算法根据源IP地址或者请求入参的哈希值来分配请求。这样可以保证来自同一源IP地址或者同一个请求总是被分配给同一台服务器。 一致性哈希（Consistent Hashing）：对普通Hash算法的一个改进，这种算法主要用于分布式系统，它可以在服务器集群的数量发生变化时，最小化重新分配的数据。 设想我们有这样一个场景：有一个分布式服务，我们需要为这个服务构造一个本地缓存，当服务的机器数很多的时候，同一个key可能在多台机器上都会有缓存，如果要缓存的数据量很大的时候，同一台机器上key过多可能会导致机器内存占用率过高，严重的可能会发生OOM，这就要求缓存的key散列的分布在不同的机器上，减少单台机器的负载，需要构造一个请求入参和机器的映射关系，让相同的请求打到相同的机器上。应该采用上述何种算法提高缓存的命中率并减少缓存占用空间呢？1-6的算法，一个请求打到哪台服务器随机性很大，7-8都是hash算法，如果把请求入参hash，理论上可以保证同样的请求达到同样的机器上的。 hash负载均衡 如上图所示，假设这个服务有A/B/C/D四台机器， ","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:1:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"代码实现 package main import ( \"crypto/rand\" \"encoding/hex\" \"fmt\" \"hash/fnv\" \"net\" \"sort\" \"sync\" ) const ( keySize = 1000 traceIDLen = 16 ringSize = 100 ) func main() { hr := NewHashRing([]ServerNode{ { Name: \"grpc.app.server1.service1\", Weight: 0.89, }, { IP: net.ParseIP(\"123.33.32.1\"), Port: 8932, Weight: 0.73, }, { IP: net.ParseIP(\"123.33.32.1\"), Port: 8933, }, { IP: net.ParseIP(\"234.65.32.3\"), Port: 8932, Weight: 1, }, { IP: net.ParseIP(\"231.23.32.11\"), Port: 32322, Weight: 1.11, }, }) keys := make([]string, keySize*2) for i := 0; i \u003c keySize; i++ { keys[i] = generateTraceID() keys[2*keySize-i-1] = keys[i] } for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } fmt.Println(\"AddNodes====================\") hr.AddNodes( ServerNode{IP: net.ParseIP(\"132.232.123.223\"), Port: 1923, Weight: 0.91}, ServerNode{Name: \"trpc.app.server2.service1\", Weight: 1.21}, ) for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } fmt.Println(\"RemoveNodes====================\") hr.RemoveNodes(hr.GetNode(keys[0]), hr.GetNode(keys[1]), hr.GetNode(keys[3])) for _, key := range keys { fmt.Printf(\"%s:%s\\n\", key, hr.GetNode(key)) } } // HashRing 哈希环 // nodes 真实结点 // virtualNodes n个虚拟节点指向一个实际节点,一个实体节点变成n个虚拟结点，均匀打散。 type HashRing struct { nodes map[string]ServerNode virtualNodes map[uint32]ServerNode sortedHashes []uint32 mu sync.RWMutex } // ServerNode 服务器结点信息 type ServerNode struct { Name string // 服务名 IP net.IP // ip地址 Port uint16 // 端口 Weight float32 // 权重 } // NewHashRing 新建一个hash环 func NewHashRing(nodes []ServerNode) *HashRing { ns := make(map[string]ServerNode, len(nodes)) for _, nd := range nodes { ns[nd.String()] = nd } hr := \u0026HashRing{nodes: ns, virtualNodes: map[uint32]ServerNode{}} hr.virtualNodes = hr.generateVirtualNodes() hr.sortedHashes = hr.genSortedHashes() hr.mu = sync.RWMutex{} return hr } // AddNodes 添加结点 func (h *HashRing) AddNodes(nodes ...ServerNode) { h.mu.Lock() defer h.mu.Unlock() for _, node := range nodes { if _, ok := h.nodes[node.String()]; ok { continue } h.nodes[node.String()] = node h.addVirtualNodes(node) } h.sortedHashes = h.genSortedHashes() } // RemoveNodes 移除结点 func (h *HashRing) RemoveNodes(nodes ...ServerNode) { h.mu.Lock() defer h.mu.Unlock() for _, node := range nodes { delete(h.nodes, node.String()) h.deleteVirtualNodes(node) } h.sortedHashes = h.genSortedHashes() } // GetNode 获取结点 func (h *HashRing) GetNode(key string) ServerNode { h.mu.RLock() // Use read lock instead of write lock defer h.mu.RUnlock() if len(h.virtualNodes) == 0 { return ServerNode{} } hashValue := hash(key) if h.sortedHashes[len(h.sortedHashes)-1] \u003c hashValue { return h.virtualNodes[h.sortedHashes[0]] } i, j := 0, len(h.sortedHashes)-1 for i \u003c j { mid := i + (j-i)/2 if h.sortedHashes[mid] \u003e= hashValue { j = mid } else { i = mid + 1 } } if h.sortedHashes[i] \u003e= hashValue { return h.virtualNodes[h.sortedHashes[i]] } return h.virtualNodes[h.sortedHashes[0]] } func (h *HashRing) generateVirtualNodes() map[uint32]ServerNode { virtualNodes := make(map[uint32]ServerNode) for _, node := range h.nodes { for i := 0; i \u003c int(ringSize*node.Weight); i++ { virtualNode := fmt.Sprintf(\"%s#%d\", node, i) virtualNodes[hash(virtualNode)] = node } } return virtualNodes } func (h *HashRing) addVirtualNodes(node ServerNode) { for i := 0; i \u003c int(ringSize*node.Weight); i++ { virtualNode := fmt.Sprintf(\"%s#%d\", node, i) h.virtualNodes[hash(virtualNode)] = node } } func (h *HashRing) deleteVirtualNodes(node ServerNode) { for i := 0; i \u003c int(ringSize*node.Weight); i++ { delete(h.virtualNodes, hash(fmt.Sprintf(\"%s#%d\", node, i))) } } func (h *HashRing) genSortedHashes() []uint32 { hashes := make([]uint32, 0, len(h.virtualNodes)) for node := range h.virtualNodes { hashes = append(hashes, node) } sort.Slice(hashes, func(i, j int) bool { return hashes[i] \u003c hashes[j] }) return hashes } func hash(key string) uint32 { h := fnv.New32a() _, _ = h.Write([]byte(key)) return h.Sum32() } func (s ServerNode) equal(node ServerNode) bool { if len(s.Name)","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:2:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"实际应用","date":"2023-07-09","objectID":"https://www.bardblog.cn/consistent-hash/:3:0","tags":["hash","algorithm","skiplist"],"title":"一致性hash算法","uri":"https://www.bardblog.cn/consistent-hash/"},{"categories":["technology"],"content":"概念 跳表是一种很特殊的数据结构，可以把跳表理解为一个多层链表，每一层都是一个有序链表，链表之间通过指针连接，并且最底层的那个链表保存跳表完整的元素，跳表示意图如下： 跳表示意图 可以看到除了最后一层链表，每一层链表元素都有可能缺失。 小结一下跳表的基本特征： 每一层都是一个按照结点的score有序的链表 链表结点key全局唯一，score可以相同 不同层链表相同结点之间通过指针相连 最底层链表含有跳表所有元素 由此可以抽象化出跳表的数据结构： // skipList 跳表数据结构 // Data 链表结点数据 // next 指向下一个节点指针，同一层链表结点按照Score非递减 // down，与下一层连接指针，当前节点p p!=nil\u0026\u0026p.down!=nil 满足 p.Data==p.down.Data type skipList struct { Data Data next *skipList down *skipList } // Data 数据类型 type Data *Element // Element 链表结点格式 // Key: zSet的成员key，全局唯一 // Score: zSet的成员对应的分数，可以一样 type Element struct { Key string Score int } ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:1:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"插入流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:2:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"删除流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:3:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"更新流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:4:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"查询流程 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:5:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"代码实现 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:6:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"实际应用 ","date":"2023-07-06","objectID":"https://www.bardblog.cn/redis-zset-implemention/:7:0","tags":["redis","algorithm","skiplist","zSet"],"title":"zset分析与实现","uri":"https://www.bardblog.cn/redis-zset-implemention/"},{"categories":["technology"],"content":"介绍MySQL的核心概念","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"MySQL 介绍MySQL的一些核心概念以及它们的底层实现,以下都是基于MySQL的InnoDB存储引擎。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:0:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"SQL语句执行流程 我们刚开始学习SQL的时候，第一个学的就是select语句了，以下就是一条最简单的查询语句: // 在student表中查询一条id为1的记录 select * from student where id=1; 那么执行这条SQL语句的全流程是什么呢？MySQL内部执行这条简单的SQL语句都做了哪些事，内部发生了什么呢？带着疑问开始学习MySQL，了解MySQL的内部架构。 先从全局的角度来看一条SQL语句的执行流程，从图中可以看到SQL语句从客户端到到数据存储整个流程以及MySQL的架构所包含的模块。 MySQL执行流程 可以看到MySQL内部分为两层，Server层和存储引擎层。 Server层负责建立和客户端连接、分析、优化和执行SQL语句。Server层和存储引擎无关，MySQL的核心模块都是在Server层实现，包括连接器、解析器、预处理器、优化器、执行器，此外MySQL的内置函数和所有跨存储引擎的功能都是在Server层实现/。 存储引擎层负责数据的提取和存储。存储引擎有多重，常见的有InnoDB、MyISAM、Memory，提供给Server层的接口都是一样的，只是具体实现不同。本文主要就InnodDB存储引擎展开，InnoDB也是MySQL的默认存储引擎。我们熟悉的MySQL的一些概念，如索引、事务、锁等都是在存储引擎层实现的，InnoDB的索引类型是B+树，我们在数据库表中创建的主键索引、联合索引、普通索引等都是用的B+树索引 以上介绍了一下MySQL的整体架构，总的架构来说“不算复杂”，就Server层和存储引擎层，下面就具体细节展开。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"连接器 如果想要对MySQL进行增删改查操作，首先肯定是要和MySQL建立连接才能继续接下来的操作，一般使用如下命令和MySQL服务建立连接。 # -h 指定域名或者ip地址 # -u 指定用户名 # -p 指定密码，从风险角度考量一般不写死，而是在执行命令后手动在控制台输入 mysql -h ip -u user -p 如： mysql -h 192.168.1.111 -u root -p 因为MySQL的的传输层协议是基于TCP的，所以建立连接的过程需要经过TCP三次握手。如果MySQL服务器运行正常，在建立TCP连接后，会验证我们的用户名和密码是否正确，如果用户名或者密码不对，就会报错：Access denied for user。如果用户名和密码都是ok的，连接器就会根据用户名查询改用户具有的权限，把权限保存在内存里，在改次连接断开之前，即便是管理员修改了用户的权限，也不会影响用户在本次连接的权限，只会在下次建立连接的时候才会使用新的权限，在本次连接生命周期中，用户的所有读写操作的权限都是基于认证的时候保存在内存的权限。 可以使用如下命令查看当前mysql服务器建立的脸颊情况 mysql\u003e show processlist; +----------+------+--------------------+-------------+---------+------+-------+------------------+ | Id | User | Host | db | Command | Time | State | Info | +----------+------+--------------------+-------------+---------+------+-------+------------------+ | 10773010 | root | 10.99.17.131:21086 | NULL | Sleep | 210 | | NULL | | 10773094 | root | 10.99.17.131:23980 | mysql_learn | Sleep | 72 | | NULL | | 10773150 | root | 10.99.17.131:25924 | NULL | Query | 0 | init | show processlist | +----------+------+--------------------+-------------+---------+------+-------+------------------+ 3 rows in set (0.02 sec) 可以看到,有三个用户名为root的用户和MySQL服务建立了连接，其中Id为10773010的用户使用的db是空而且Commond的值是Sleep，意味着该用户执行连接命令后没有再执行过其它任何命令，并且空闲等待的时间为210s（Time列） 那么这个空闲等待时间会一直无限递增吗？换句话说MySQL连接会一直保存着吗？ 肯定是不可能的，不可能我一年前建立的一个连接然后忘了啥都没干，但是MySQL还记着一直给我保存着，显然这是不可能的（就好比去餐厅吃饭，预约了一个座位，超过一定时间没去肯定会给你取消的），MySQL也有类似的机制，如果一个连接长期在哪空转啥都不干，超过一定时间内就会自动断开，这个断开时间（最大空闲时常）是由 wait_timeout这个参数控制的，默认的是26060=7200s。 mysql\u003e show variables like 'wait_timeout'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 7200 | +---------------+-------+ 1 row in set (0.03 sec) 如果我们看某个连接不爽，也可以使用 kill connection +Id命令手动kill这个连接，我现在想要干掉10773010这个连接，只需要执行如下命令： mysql\u003e kill connection +10773010; Query OK, 0 rows affected (0.02 sec) mysql\u003e show processlist; +----------+------+--------------------+-------------+---------+------+-------+------------------+ | Id | User | Host | db | Command | Time | State | Info | +----------+------+--------------------+-------------+---------+------+-------+------------------+ | 10773094 | root | 10.99.17.131:23980 | mysql_learn | Sleep | 895 | | NULL | | 10773150 | root | 10.99.17.131:25924 | NULL | Query | 0 | init | show processlist | +----------+------+--------------------+-------------+---------+------+-------+------------------+ 2 rows in set (0.03 sec) mysql\u003e 可以看到10773010这个连接已经被kill掉了 可以无限和MySQL服务器建立连接吗？ 就像任何资源都是有上限的，MySQL的连接也是宝贵的资源，肯定不会也不能无限提供，就像最大空闲市场是由wait_timeout这个参数控制的一样，最大连接数是由 max_connections参数控制的 mysql\u003e show variables like 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 2500 | +-----------------+-------+ 1 row in set (0.03 sec) mysql\u003e 比如我的MySQL服务器的最大连接数是2500，意味着在同一时刻最多只能保持2500个连接，超过这个值，系统会拒绝接下来的连接请求，并且报错Too many connections。 我们知道HTTP协议是基于TCP协议的，HTTP有长连接和短连接，同样的MySQL也有长连接和短连接。 长连接：顾名思义，存活周期很长的连接，客户端在和MySQL建立连接后，每次执行完一条SQL语句，连接不会马上释放，而是保存着，下次再执行SQL语句不用重复建连了，而是可以复用这条连接。 短连接：故名思义，存活周期较短的连接，客户端在和MySQL建立连接后，每次执行完一条SQL语句，连接马上释放，下次再执行SQL语句需要重新建连。 # 长连接 经过tcp三次握手和MySQL建立连接 执行sql1 执行sql2 执行sql3 .... 执行sqln 经过tcp四次挥手和MySQL断开链接。 # 短连接 经过tcp三次握手和MySQL建立连接 执行sql1 经过tcp四次挥手和MySQL断开链接。 经过tcp三次握手和MySQL建立连接 执行sql2 经过tcp四次挥手和MySQL断开链接。 经过tcp三次握手和MySQL建立连接 执行sql3 经过tcp四次挥手和MySQL断开链接。 .... 经过tcp三次握手和MySQL建立连接 执行sqln 经过tcp四次挥手和MySQL断开链接。 可以看到长连接和短连接各有优劣。 长连接的好处在于不用每次执行SQL语句都建立连接，做到资源复用，而且可以降低SQL语句耗时（省去建立连接的三次握手过程）；坏处在于连接长期得不到释放，连接是需要占用MySQL的系统资源的，如果长连接累积的很多，可能会导致MySQL系统OOM，所以最大连接数不能配置的太高。 短连接的好处在于每次执行完SQL语句连接都被释放掉了，降低MySQL系统负载，坏处是每次执行SQL语句都需要建立连接，会增加SQL语句执行耗时。 在实际开发过程中，一般推荐使用长连接，因为可以减少建连和断连的过程，但是长连接过多可能会导致MySQL系统高负载，导致服务异常重启。 长连接长期不释放，MySQL系统内存会占用很大，如何解决？ 一般来说，有以下几种解决方式： 设置合理的超时时间在MySQL服务器和客户端之间建立长连接时，可以设置合理的超时时间。通过配置wait_timeout和interactive_timeout参数，可以控制连接在闲置一段时间后自动关闭。这样可以确保长时间不活跃的连接被释放，释放相关的资源。 使用连接池使用连接池管理连接是一种常见的解决方案。连接池可以维护一组预先创建的连接，并在需要时分配给客户端。连接池会复用连接，避免频繁地创建和销毁连接，从而减少资源消耗。连接池通常还提供连接的管理和监控功能，可以根据需求配置连接的最大数量、超时时间等参数。 显式关闭连接在编写应用程序代码时，确保在不再需要连接时显式关闭连","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"查询缓存 建立连接之后，客户端就可以向MySQL服务器发送执行SQL了，MySQL服务器收到SQL语句后首先判断这个SQL语句是不是查询语句（根据SQL语句第一个字段是不select来判断），如果是查询语句的话，MySQL就会先去查询缓存里面查找是否有这个SQL查询语句的缓存结果，如果有的话，直接就返回给客户端，不进行下一步，缓存是以key:value形式存储的，key是SQL查询语句，value是查询结果。 看起来很美好，但是需要关注一下这里的缓存命中以及有效率的问题，在一般情况下，MySQL的查询缓存失效率是很高的，因为只要MySQL表中有数据更新，缓存就会失效。比如我要查询 select * from student where id=1; 第一次查询这条记录后，MySQL会把id=1的查询结果刷到缓存中，但是如果MySQL执行了更新语句，这个缓存就会失效。 比如MySQL更新了id=2的数据 update student set name='张三' where id=2; 我们可能会在想，为啥MySQL做的这么粗暴呢，更新id=2不影响id=1的结果啊，为啥要把id=1的缓存干掉？因为MySQL不知道更新id=2这条记录是否会影响id=1的这条记录，或者说想要知道是否会影响的代价太大了(很难判断是否会有影响，如果真要判断，付出的代价相比于缓存的收益更大，得不偿失)，MySQL为了保证数据的一致性，干脆只要一有更新操作就让缓存失效。 从上面的分析可以知道，这个缓存好像没啥用，因为即便是读多写的场景，也不能完全不写，而只要有写操作，就让表的所有缓存失效，代价是很大的，成本和收益不成正比，所以在MySQL8.0的版本，去掉了查询缓存这个功能。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"解析器 一条SQL语句如果能够执行成功，首先肯定是符合MySQL的SQL语法规范的，这个规范可以理解为我们和MySQL定的规则，我们遵循这个规则来写SQL语句，MySQL同样也要遵循规则去解析执行我们写的SQL语句，不可能说我们随便写一段字符串，MySQL也去给我们执行。在执行SQL语句之前，MySQL需要理解我们这条SQL语句是干嘛的，是增、删、改还是查，SQL语句涉及到哪些表，哪些表字段？这些都需要也可以根据语法规则去提取出来的，这实际上就是解析器要做的事。 解析器会做两件事： 第一件事： 语法分析MySQL会根据和我们协定的语法规则检查SQL语句是否有语法错误，如果有语法错误，会直接报错You have an error in your SQL syntax,比如我们执行如下语句 mysql\u003e slect * from friend where id=1; ERROR 2013 (HY000): Lost connection to MySQL server during query No connection. Trying to reconnect... Connection id: 10788396 Current database: mysql_learn ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'slect * from friend where id=1' at line 1 mysql\u003e 把select打成了slect，MySQL根据语法规则校验这条SQL语句是不符合语法规范的，就直接报错了。这个类似于我们后台开发常用的参数校验。 第二件事： 词法分析：不管是多复杂的SQL语句总是有规律可循的，比如where关键字后面肯定是查询条件，from关键字后面是表名， MySQL实现了词法解析器，根据SQL语句提取出来表名、SQL类型、表名、字段名，where查询条件等，做好准备工作给到后面模块使用。 需要注意的是上面说到语法检查和词法分析是在解析器做的，但是判断表名和字段名是否存在这些并不是在解析器层做的，可以理解为解析器这一层都是本地逻辑，不涉及到网络或者API调用。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"预处理器 SQL语句经过解析器后，就可以判断这条SQL语句是可能可以被执行的，为什么是可能呢？因为经过解析器只能说明这条SQL语句语法是没问题的以及提取了表名等需要执行的SQL语句包含的关键信息，但并不代表这个SQL语句就一定能执行成功，就像上面说的，如果SQL语句查询一张不存在的表，那么肯定不会执行成功的。预处理器主要干两件事： 检查解析器从SQL语句中提取出来的表名、字段名是否存在。 将select *的*替换成实际的字段名 这一步就不像解析器那样是纯本地逻辑的，在预处理阶段，需要先读取表的信息，进而检查表名、字段名是否存在，以及将 *替换成实际的字段名，这就涉及到API调用了。 我们执行如下SQL语句报错，这个报错其实是预处理器返回的。 mysql\u003e select * from frined where id=1; ERROR 1146 (42S02): Table 'mysql_learn.frined' doesn't exist mysql\u003e ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"优化器 经过解析器和预处理器后，SQL语句来到了优化器，严格来说，到了优化器，不能再叫SQL语句了，因为经过前面两位大哥的处理之后，SQL语句已经面目全非，到了优化器这一层，可以确定这条SQL语法是完全合法的，既没有语法错误，表名和字段名也都存在。那为啥还要经过优化器处理，直接丢给执行器执行不就行了吗？肯定不行，如果这么无脑的话，那MySQL估计没人用了。优化器会根据SQL语句以及当前表的实际数据情况等选择一个合适的执行方案，比如一条SQL查询语句有多个索引，优化器就要分析判断使用哪个索引查询代价更小，又比如如果表里的数据量很小的时候，全表扫描代价可能更小，优化器可能会选择全表扫描而不选择使用索引。 回顾一下我们经常使用的explain命令，在select前面加上explain关键字就可以知道本次查询执行计划。 查询语句一 mysql\u003e explain select * from `like` where id=1; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | like | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.04 sec) mysql\u003e 查询语句二 mysql\u003e explain select * from `like` limit 1; +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ | 1 | SIMPLE | like | NULL | index | NULL | uk_user_id_liker_id | 8 | NULL | 3 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.03 sec) mysql\u003e 可以看到两次查询key这一列都不为空，查询语句一MySQL选择了PRIMARY主键索引，查询语句二则选择使用了uk_user_id_liker_id唯一索引，如果key为空，则代表没有使用索引，而是使用了全表扫描。 在实际开发中，一摸一样的SQL语句，在不同时刻执行执行计划可能会不一样，执行计划取决于很多因素，包括索引、表数据量大小等。总而言之MySQL会根据很多条件选择一种相对最优的执行计划减少SQL语句执行成本。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:5","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"执行器 经过前面的\"前戏\"后，终于要进入正题了，正式执行SQL语句了，执行器说白了就是MySQL的Server层和存储引擎层的一个桥梁，执行器并不实际执行SQL语句，而是通过API接口把经过一系列处理后的\"SQL语句\"丢给存储引擎执行，等待存储引擎返回执行结果，再把执行结果返回给查询缓存以及连接器。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:6","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"小结 总结一条SQL语句从客户端发起到客户端收到执行结果的过程 客户端经过连接器和MySQL服务端建立连接，连接器会校验用户名及密码是否正确，以及确定用户的权限，并存储用户的权限在内存中，在本次连接的生命周期中，用户的权限是一致的。 建立连接之后，请求来到了解析器，解析器主要干两件事：校验SQL语句是否符合语法规范，有语法错误直接报错；提取 SQL语句的关键字、表名、表字段关键信息。 经过解析器校验语法和提取关键信息后，请求到了预处理器，预处理器主要是确认SQL语句的表名字段名是否存在如果不存在直接报错，以及将 *关键字替换成实际的表字段。 经过上述检查和处理，就表示这条SQL语句是可执行的，但是在执行之前，服务端需要分析判断索引、当前数据表数据情况优化SQL语句执行，选择一个相对最优的方式去执行。 执行器收到优化器优化后的SQL语句，将SQL语句丢给存储引擎，然后等待执行结果将结果返回给执行器和查询缓存。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:1:7","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"索引 上述详细阐述了一条SQL语句从客户端到执行器丢给存储引擎整个流程，以上都是在MySQL的服务层实现的与存储引擎无关。本节主要介绍InnoDB存储引擎的索引概念和底层实现以及具体应用。 说到索引，首先要明确一下在MySQL中有哪些索引，根据不同维度划分，有以下几类索引 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"数据结构划分 索引类型\\存储引擎 InnoDB MyISAM Memory B+Tree Yes Yes Yes HASH No,会有自适应hash，存储引擎自动实现，没法指定。 No Yes Full-Text Yes Yes No InnoDB是MySQL默认的存储引擎，实际业务开发中，也比较推荐使用InnoDB，InnoDB事实上成了默认标准了 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"物理存储划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"字段特征划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"字段个数划分 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:2:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"三大日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"undo日志 undo日志是innodb引擎实现的一个 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"redo日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"bin日志 bin日志是mysql服务层实现的用于数据持久化的一种日志 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:3:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"各种锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"表级锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"行锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"间隙锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"临键锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"插入意向锁 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:5","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"自增锁 自增锁（Auto-Increment Lock）主要用于生成自增主键ID。在InnoDB中，当一张表的主键列设置为自增（AUTO_INCREMENT）时，每次插入新记录时，主键列的值会自动递增。自增锁确保在同一时间只有一个事务能够获取自增列的下一个值，避免在高并发场景下出现主键ID重复的问题。 当一个事务需要插入一条新记录时，它会请求自增锁，获取自增列的下一个值作为主键ID。在事务完成插入操作并释放自增锁之前，其他试图插入新记录的事务需要等待。这样，自增锁可以确保主键ID的唯一性，避免数据不一致的问题。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:4:6","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"事务 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"原子性 底层实现 一组操作要么都成功要么都失败，称之为原子性。设想一个场景，我现在有一个多写逻辑，有A、B、C三个步骤，A和B都成功了，C失败了，这个时候需要回滚数据恢复到这个逻辑之前，也就是要撤销A和B，这就要求我们需要知道被A和B修改成功的数据被修改之前的原始数据，然后用这个原始数据回滚，所以需要有一个地方记录被修改之前的原始数据。在Innodb中，这个存储被修改数据在修改之前的数据就是undo日志，也就是说，innodb的事务原子性是通过undo日志实现的。具体过程如下： Undo日志实现原子性 修改一行或多行数据，会在这个事务的update undo log链表中插入修改之前的数据，使用头插法按照修改的顺序插入数据，这些数据是按照修改的顺序逆序存储的，也就是说，最后修改的数据会被放在链表的最前面。 插入/删除一行或多行数据，会在这个事务的insert undo log链表中记录被插入/删除数据的主键id，使用头插法按照修改的顺序插入主键ID，这些ID也是按照插入的顺序逆序存储的，也就是说，最后插入的数据的ID会被放在链表的最前面。 如果事务执行失败或者被回滚，InnoDB会遍历上述日志链表，按照顺序执行回滚操作，以此来撤销事务中的所有修改。 小结 innodb借助undo日志实现事务的原子性，具体做法的在每次更新或者插入/删除数据之前先备份一下当前数据到undo日志链表中，当事务回滚的时候就可以遍历执行unlo日志链表达到回滚数据的目的 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:1","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"持久性 底层实现 持久性要求在数据库发生崩溃（如宕机、拔电源的时候，数据也能够保证不丢失。确保数据库从宕机等状态恢复的时候能够从磁盘中恢复尚未写到binlog的日志。和unro日志记录修改之前的数据不一样，redo日志是记录被修改后的数据，当数据库发生崩溃重启的时候，会根据unlo日志回滚尚未提交成功的事务。然后根据redo日志重放事务。 假设现在有两个事务，A事务执行到一半，B事务执行完成并提交，系统崩溃宕机，系统重启后，redo日志重放B事务并提交，undo日志回滚A事务。这就是InnoDB如何使用Undo日志和Redo日志来恢复系统状态的。通过这两种日志，InnoDB可以确保在系统崩溃后，所有已提交的事务的修改都不会丢失，所有未提交的事务的修改都可以被撤销，从而保证了数据库的一致性和持久性。 每次当一个事务进行修改操作时，InnoDB会生成相应的Redo日志，这个Redo日志有一个LSN，这是一个递增的数字，用来标识每个Redo日志的唯一性。同时，每个数据页在内存中也有一个LSN，表示这个数据页到哪个点被修改过。当这个Redo日志被应用到数据页时，也就是数据页被修改时，数据页的LSN会被更新为这个Redo日志的LSN。这样，数据页的LSN就表示了这个数据页被修改的最后一次操作。在重放过程中，InnoDB会比较Redo日志的LSN和数据页的LSN，只有当Redo日志的LSN大于数据页的LSN时，才会重放这个日志，也就是说，只有当Redo日志中的修改还没有被应用到数据页时，才会重放这个日志，所以在回放的时候并不是无脑回放所有的redo日志，而是会判断lsn丢弃掉已经持久化数据到数据页的redo日志，避免数据重复写入到数据页。mysql使用两阶段提交保证redo log和bin log的一致性，简单来说才数据写入bin log的时候会先写redo 日志，此时redo日志的状态为prepare，写redo日志成功后继续写bin log，bin log写成功后最后再把redo log的状态从prepare 改为commit。两阶段提交的目的是为了保证主库和从库数据的一致性，在事务崩溃的时候借助redo日志，可以恢复本机的数据页的数据，但是主从同步是借助bin log完成的，如果没有两阶段提交，可能会导致主库和从库的数据不一致。 两阶段提交保证binlog数据和本机数据一致性 小结 持久性依赖于undo和redo日志，每次事务提交的时候就会把redo日志落盘，当系统崩溃恢复的时候，会进入redo阶段回放日志，redo阶段的目的是为了将成功提交但还没持久化到数据页的那部分事务进行回放恢复；redo回放完成后进入到undo阶段，undo阶段的目的是将因系统崩溃导致未提交的事务的数据进行回滚避免脏数据。在redo阶段和undo阶段期间会阻塞所有写请求直到重放和恢复完成，这是为了确保数据库在恢复过程中保持一致性，避免在恢复过程中产生新的错误或不一致；而对于读请求则视事务的隔离级别以及数据库系统的配置而定。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:2","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"隔离性 在mysql中有四种隔离级别，按照隔离程度分别是读未提交、读已提交、可重复读、串行化。所谓隔离性指的是多事务之间是隔离的，互相不干扰，抛开事务来看，我们日常写业务代码的时候，涉及到对多个线程共享的数据进行读写的时候，为了保证数据的安全性，一般会对共享数据进行加锁，其实这个“加锁”就是mysql中的最高隔离级别串行化。在mysql中为了兼顾性能和数据一致性，提供了不同的隔离级别，业务可以根据自己实际使用情况选用不同的隔离级别。 读未提交 最低的一种隔离级别，在事务中读到的数据永远是当前数据库最新的数据，在一个事务执行过程中，如果有其它事务对该事务读取的数据进行修改，可以读到其它事务修改但还未提交的数据。可以把它类比于多线程对共享数据进行读写，但不做任何并发保护，可能会导致读到很奇怪的数据，甚至读到修改一半的数据。读未提交因为是最低的隔离级别，性能自然也是最好的，因为不需要任何手段保护数据，但是数据一致性也是最差的。读未提交可能会导致脏读(读到其它事务更新但又回滚的数据)、不可重复读（多次读同一条数据结果不一样）幻读（多次读同一个范围内的数据返回的结果少了或者多了数据）。读未提交适用于对性能要求比较高，但是对于数据一致性要求稍弱的场景，比如实时数据分析、缓存预热、非关键业务数据查询 读已提交 可以读到其它事务提交的数据，底层使用mvcc+redo实现，每次查询的时候都会开启一个快照，获取当前还没提交的事务ID列表，下一个事务ID是上述列表中最大事务ID+1，判断读到的数据的的事务ID是否在这个还未提交的事务ID列表中以及是否是下一个事务ID，如果不在的话，就认为数据是可信的，直接返回，否则的话会沿着回滚链表指针向后遍历直到找到可信的数据。因为每次查询都会开启一个快照，所以如果第一次快照里面的某些事务在第二次开启快照的时候提交了，第二次开启快照的时候未提交事务ID列表就没有第一次和第二次快照这个时间区间内的事务（因为已经提交了），所以会读到本事务执行期间其它已经成功提交的事务的数据，所以会造成不可重复读。在读已提交这个隔离级别，只有行锁和表锁起作用。 可重复读 实现和读已提交类似，区别在于rr隔离级别会在事务启动的时候开启一个全局快照，而不是像读已提交每次都会开启一个快照，也就是说rr级别下，整个事务周期中其它未提交事务ID列表和下一个事务ID是保持不变的，这样的好处在于其它事务提交的数据跟我无关，在快照读的情况下可以避免不可重复读和幻读的问题。但是需要注意的是，对于当前读（如 select .. for update /update /delete等语句）会读到当前的最新数据，对于当前读，rr会使用next-key lock+行锁来尽量保证避免出现幻读的问题，但是不能百分之百保证幻读，典型的如下两个例子。⚠️：幻读在rr隔离级别下只会出现在当前读这个场景，对于普通读是没有影响的。 case1 begin select name from user where id=2; # user表中不存在id=2这条数据，读出来是空 #....在这个区间内另一个事务执行 insert into user (id,name) values(2,\"lisi\")并成功提交 update user set name='zhangsan' where id=2; # 因为此时user表中有id=2这条数据，update会当前读，所以这条数据成功更新了 select name from user where id=2; # user表中存在id=2这条数据，并且是由本事务更新的，所以读出来这条数据是 `zhangsan` commit # 在以上事务执行过程中，出现一模一样的sql执行语句两次执行结果不一样，出现了幻读，由于update是当前读会更新表中的数据，第二次读的时候发现表中隐藏列的指针代表的版本是本事务修改的，所以认为数据是可信的，返回结果。 case2 begin select * from user where id\u003e3; # 此时有表中有三条数据 id 分别为4、5、6 #....在这个区间内另一个事务执行 insert into user (id,name) values(7,\"lisi\")并成功提交 select * from user where id\u003e3 for update; # 因为for update 是当前读，并且由于第一次读是快照读不回上写锁，所以本次读会读出四条数据，id 分别为 4、5、6、7 commit # 两次读的数据不一样，出现了幻读，原因在于第一个select语句是快照读只会加读锁不回加写锁，也就是说阻止不了其他事务插入删除或者更新数据，而刚好第二次读是当前读，读到的最新的数据，导致了两次读取数据不一样。但是如果把两个语句换个顺序就不会出现幻读的问题了，因为for update会加next-key lock(gap 锁+行锁)，会锁住数据其他事务在本事务提交之前是不能进行增、删、改的操作 begin select * from user where id\u003e3 for update; # 此时有表中有三条数据 id 分别为4、5、6，会加间隙锁[4,+∞),直到本事务提交才释放 select * from user where id\u003e3; # 因为第一次select加锁了，所以本次读出来的数据和第一次一样，不会出现幻读。 commit 串行化 最高的一种隔离级别，类似于加读写锁，同一时刻只有一个事务在执行，类似于单线程的方式。这种隔离级别下不回出现以上三种隔离级别的问题，但是性能也是最差的。一般用在对于数据一致性要求极高的场景，如银行、金融等领域。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:3","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"一致性 上述疏导的原子性、隔离性、持久性，都是手段，一致性才是目的，换句话说mysq实现了原子性、持久性、隔离性保证数据的一致性。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:5:4","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"数据结构 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:6:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology"],"content":"内存","date":"2023-07-01","objectID":"https://www.bardblog.cn/mysql-core-concepts/:7:0","tags":["MySQL","InnoDB"],"title":"MySQL核心概念","uri":"https://www.bardblog.cn/mysql-core-concepts/"},{"categories":["technology","interview"],"content":"记录社招面试过程及复盘","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"项目总结 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:0:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"底层存储设计 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:1:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"数据结构 所有的关系链数据都是使用redis的hash数据结构来存储的，设计了一个通用的适配层，高性能、安全、多租户的通用存储系统。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:1:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"背景 从qq群历史架构-\u003ediscord-\u003e需要支持千万级关系链的读写能力,，关系链复杂，超大群，热点效应。通用、高并发、安全、百万人量级关系链系统。 构建一个存储适配层，read和write。write会聚合排队写 redis底层设计 首先介绍一下业务背景，几个核心的关系链场景基本概念，解释为啥要使用redis作为db使用，然后解释说明为啥要用redis的hash这种数据结构，排除法来选择。以频道下的人这个关系链存储来展开，再引申到key和热 key 问题怎么解决？ 以频道ID作为key，filed是成员id，filed对应的value是成员基本信息，入昵称、角色等业务信息，是pb序列化后的结果。 频道初始化的时候有两个hash结构的key，一个称之为member，一个称之为info，member很大，info很小，存储频道业务和元数据路由信息。每个member表分配beginIndex,endIndex。 拆表/合并策略：类似于二叉树的结点分裂，每次一分为二，计算qq号的hash值，分配到左区间还是右区间，并更新路由信息，大概耗时90多ms；如果发现某个子表的数量很小，尝试和它的另一半合并，并更新路由信息，大概耗时40ms。 版本号控制，全局有一个版本号，每个子表也有一个版本号；控制当前的版本，版本号是递增的，初始化的时候是0，每次数据更新或者分裂都会更新版本号。 支持多租户，上述只是以频道下这个人作为例子，实际上我们的这套存储设计抽象是跟业务无关的，抽象，支持多租户0成本接入。 在redis之上构建的本地缓存 缓存子表，没台机器存储全量大频道数据，目前占用8G左右，三大策略保证一致性； 1.广播更新（内网，增量）；2后台定时轮询子表版本号，版本号落后，更新数据（全量）；3；缓存命中抽样上报，低于阈值触发熔断（降级熔断）。 排队合并写入，对于加频道/退频道请求，会本地排队聚合写入，减少广播次数。请求合并. 容器化部署，自动伸缩,128GB*24=3TB内存， 内存使用率54%，cpu使用率50%，写tps 3000多，平均每台机器100多写入请求 同时缓存Info和子表数据，精细化构建缓存和更新，减少缓存失效次数。使用合并策略，一致性hash算法路由到一台机器从redis拉取数据构建更新缓存，减少拉取流量和热key问题。写操作读取不走缓存，直接穿透db。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:1:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"私密子频道鉴权模型优化 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:2:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"背景 历史原因导致私密子频道鉴权会扩散查私密子频道成员，当私密子频道活动比较多的时候（触发大量读鉴权），叠加多个写操作。会对底层产生较大压力，触发告警。热key问题。优化 人-频道、人-子频道、人-身份组、子频道-身份组，人的身份组和子频道身份组取交。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:2:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"优化 优化人的子频道这个存储，将反向关系链做准，以反向关系链鉴权人在不在频道，热点问题变成散列问题。 存储模型优化：历史原因导致，鉴权模型私密子频道+身份组+私密子频道下的人+身份组下的人，干掉私密子频道下的人，把私密子频道也理解为一个隐藏身份组，梳理上下游服务，读写改造灰度、历史数据迁移，发布节奏控制，风险把控 基于关系链存储构建二级cache缓存：梳理业务，细化人和子频道纬度，哪些地方写会影响缓存，子频道-身份组（本地）和人-身份组（redis）纬度的缓存。细化写逻辑。热点问题变成散列问题 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:2:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"事件中心拉平 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:3:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"背景 王者荣耀等超大频道运营活动导致一下子感知到很多人，推送信令触发拉取操作，千人千面对后台关系链产生较大压力。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:3:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"优化 削峰拉平 redis实现延迟队列削峰拉平 local score = redis.call('ZSCORE', KEYS[1], KEYS[2]) if (score == false or score %% %d \u003e 0) then score = ARGV[1] redis.call('ZADD', KEYS[1], ARGV[1], KEYS[2]) end redis.call('ZADD', KEYS[2], score, ARGV[2]) return redis.call('EXPIRE', KEYS[2], ARGV[3])` # 三类key 1.KEYS[1]：taskKey（zset):单个，任务集合 score：当前时间戳 member:guild_id+even_type+ip 2.KEYS[2]:eventKeys(zset):多个，具体的事件,和taskKey中的member对应 score: KEYS[1]中的时间戳 member:事件的内容序列化后的内容 3.last_consumer_score: 单个，每次从taskKey取任务之前拉取，消费完成后设置。 每300ms从taskKey取任务，再从eventKeys中取任务，根据事件类型进行合并分包写到一个下游kafka，5000个人一个包。每次执行完任务后更新last_consumer_score 兜底逻辑：考虑到服务宕机等问题，可能某台机器写到taskKey的任务没来得及消费，这个时候需要另外一个线程执行兜底逻辑消费未被消费的任务，会使用分布式锁上锁，防止多台机器重复消费。 下游服务消费写入的kafka执行推送任务，复用大群通道推送，限流控速。 非关键信息增量推送 对于频道名称或者其它不是很关键的信息，直接走增量推送，把数据直接推给客户端，不用触发拉取。 推失败也没关系客户度会有补偿逻辑。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:3:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"ID转换服务重写 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:4:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"背景 底层id转换服务，请求量大上游多，数据量key超多，对服务稳定性以及耗时有严苛要求。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:4:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"现状 单机缓存构建耗时过长，10分钟后机器才能提供服务，且随着id数增长，耗时会越来越大。 bigcache占用空间过大（bigcache空间占用由map+对象序列化后内存消耗组成），线上30GB内存最多存储2亿数据。 服务中大量使用int转string、pb打解包等方法，以及不合理的打点，影响整体性能。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:4:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"优化 使用自己实现的cache代替原来的bigcache，一亿个键值对，1亿数据占用不到1.7GB，64GB机器可支撑30亿正反数据（15亿账号） 1.本地cache 使用三个数组实现，单条kv数据是8（key)+8(val)+1(时间）=17个字节，节省空间，内存更紧凑，相比于map空洞更少 2.分片设计，根据hash算法把key hash到不同分片,降低锁粒度，目前是3w个分片，每个分片3000多条数据。 3.读取使用二分查找的方式查找数据，单分片单次查找速度极快33ns，内置map是20ns，bigcache是109ns。 4.基本数据类型，省去序列化反序列化过程，直存直取。后台任务定时扫描清理老数据，腾出空间 5.使用插入排序的方式更新数据，基本有序数据插入排序时间复杂度很快;触发容量上限会删除最老的数据，没有触发的话会按照步长扩容。 6.使用cos作为持久化数据（加密+压缩，压缩率60%）每天随机一台机器定时dump一次数据到56个cos小文件，每个文件都有hash校验和。 7.服务启动并发拉取cos数据还原加载本地内存数据，根据hash校验和剔除掉有问题文件，4s内恢复。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:4:3","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"大群通道 以人纬度的缓存，增量+全量更新逻辑，用户消息驱动+kafka增量更新消息空洞补齐+后台定时扫描全量更新，保证数据一致性 cache1: key：guild_id+sub_id:value 5000个子表 // 每个频道每个子表的全量数据 cache2: key:guild_id+uin:value：人的信息 // 缓存人在频道里面的信息，主要是权限数据 cach3: key:uin:value:map[guild_id][sub_id] //人在每个频道所属的子表信息 消息以人为纬度聚合推送（减少下行流量）+消息精简+消息分级，高优先级先推，低优先级后推。减少推送次数+减少推送流量。 消息精简，焦点上报，客户端维护一份焦点，在推送消息的时候把人的焦点信息也推送下去，客户端判断焦点和自己本地较低是否一致，不一致则上报焦点，一致则不上报，避免无效频繁上报。 token机制，atall的时候，使用token鉴权，减少拉取消息对于关系链的请求压力。构建以人纬度的缓存，做增量和全量更新。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:5:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"微服务治理 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:6:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"背景 目前4个后台组总共有600个微服务，对于底层的核心服务存在很多不合理调用情况，微服务拆分过细，接口设计不合理等问题。继续优化改造，降低风险。主要以下几个手段 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:6:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"治理 大流量底层服务推动微服务治理，抓大放小，减少重复调用，推动上下游改造。把控进度和风险。 对于大而全的接口，拆分细化，提供轻量级的接口，逐步平滑迁移。 微服务合并，将功能/代码类似的微服务合并到一个服务，减少微服务数量和链路复杂性，节省机器资源。 核心大流量服务申请调用需要走申请，需要详细说明调用目的以及调用频率，管控混乱调用， 设计不合理代码性能优化，重构，池化技术、缓存、请求合并。 推动上游服务请求合并\u0026增加缓存，优化性能节省机器资源。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:6:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"其它 架构合理：底层存储选型是否合理，数据结构/表设计是否合理，数据/扩散比模型推演,分库分表，存储拆分。 横向/纵向扩容：系统具有较好的扩展能力，留足buffer，自动扩缩容，减少人工介入。 池化技术：代码层面使用池化技术，包括连接池/协程池/对象池，复用思想。 gc调优；gc压力过大，需要分析优化，减少内存碎片，减少gc频率，减少gc次数。 锁优化，减少锁粒度，分片锁而不是全局锁，读写锁而不是互斥锁，乐观锁而不是悲观锁。 缓存：缓存预热，饿加载方式，同时尽量保证缓存一致性保，多级缓存。 全链路监控告警：包括pass、拨测、服务指标、打点监控等全链路无死角告警。监控要求全面且准确，并且针对告警有应对预案。 并发/异步：代码层面能够并发的并发，能够异步的异步，使用mq等方式解耦。 链路优化/精简，微服务架构优化，轻量级接口，减少无效请求和调用，请求聚合，减少重复请求。 限流/降级策略，非核心场景降级开关，避免阻塞主流程，保证主场景可用。 接口重试/幂等：失败重试，但是要注意重试雪崩，保证接口幂等，对冲重试。 服务全链路压测：事前压测，事前分析系统短板，事前优化。 削峰/限流策略：峰值流量削峰限流，限流防止打垮db，有损减少核心场景不可用。 服务发布，ci/cd，观测指标，灰度发布，关键日志、监控打点，紧急回滚策略。 容灾：同地多机房，异地部署，防止全死全活。 服务接口数据自修复能力，系统健壮性。数据压缩，cpu和io权衡。 降低系统耦合度，接口单一职责，接口拆分。避免大而全接口，微服务改造。 面试复盘 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:7:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"微派（挂） ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:8:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230707 微派一面（挂） bitmap数据结构底层实现，最大2^32个bit位。占用内存空间位512MB（8位占用1B） $$ 2^{32}bit=2^{10} \\times 2^{10} \\times 2^{10} \\times 2^{3} \\div 2 =1GB \\div2=512MB $$ 以下是用go语言实现的位图： var outOfRange = errors.New(\"out of range\") type BitMap struct { bits []byte size int } // NewBitMap 创建一个bitmap // size bitmap能存储最大的位 func NewBitMap(size int) *BitMap { return \u0026BitMap{ bits: make([]byte, (size+7)/8), // 向上取整 size: size, } } // SetBit 设置指定位的bit值 func (b *BitMap) SetBit(index int, val bool) error { if index \u003c 0 || index \u003e= len(b.bits)*8 { return outOfRange } byteIndex := index / 8 bitIndex := index % 8 if val { // 1 b.bits[byteIndex] |= 1 \u003c\u003c bitIndex } else { // 0 b.bits[byteIndex] \u0026= ^(1 \u003c\u003c bitIndex) } return nil } // GetBit 获取位图指定位置是否是1 func (b *BitMap) GetBit(index int) (bool, error) { if index \u003c 0 || index \u003e= len(b.bits)*8 { return false, outOfRange } byteIndex := index / 8 bitIndex := index % 8 return b.bits[byteIndex]\u0026(1\u003c\u003cbitIndex) != 0, nil } // CountRange 获取位图中指定范围内的位的数量，返回的是该范围内值为1的位的数量。 func (b *BitMap) CountRange(begin, end int) (int, error) { if begin \u003e end || begin \u003c 0 || end \u003e= len(b.bits)*8 { return 0, outOfRange } cnt := 0 for i := begin; i \u003c= end; i++ { if res, _ := b.GetBit(i); res { // 入口处已经检查参数判断，所以这里不用判断了，可以忽略error cnt++ } } return cnt, nil } // CountAll 统计整个位图中值为1的位的数量 func (b *BitMap) CountAll() int { res, _ := b.CountRange(0, b.size-1) return res } 从0～n-1这n个数中随机选择m个数，m\u003c=n，要求概率相等，选中的数不能重复 // m\u003c=n;从0~n-1这个n个数中随机选出m个数，要求等概率，并且选出的m个数不能重复 // 蓄水池算法，数学归纳法证明 func getMRandomDigits(n, m int) []int { res := make([]int, m) for i := 0; i \u003c m; i++ { res[i] = i } rand.Seed(time.Now().UnixNano()) for i := m; i \u003c n; i++ { j := rand.Intn(i + 1) if j \u003c m { res[j] = i } } return res } redis怎么减少内存占用空间？ 选用合适的数据结构来存储，比如可以用bitmap来表示大量唯一值，HyperLogLog统计唯一元素值的数量（基于数学概率，有一定误差，适用于海量数据统计）。 使用内存淘汰策略，淘汰长期不使用的键。 将同类型的元素聚合在Hash中，而不是作为键单独存储，减少键值本身的消耗，节省内存空间。 优化键名，防止键名过长。 使用LZF压缩，开启压缩，压缩和解压是在redis完成的，用户无感知。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:8:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"美团（offer) ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:9:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230711 美团一面（过） redis底层数据结构理解及原理了解? 知识的广度及深度需要提高? 发布如何从技术层面保证不出问题？ 买卖股票的最佳时机： func maxProfit(prices []int) int{ if len(prices)\u003c2{ return 0 } buyPrice:=prices[0] res:=0 for i:=1;i\u003clen(prices);i++{ if prices[i]\u003cbuyPrice{ buyPrice=prices[i] } res=max(res,prices[i]-buyPrice) } return res } func max(a,b int)int{ if a\u003cb{ return b } return a } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:9:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230719 美团二面（过） 聊项目：纯聊项目，聊了140分钟….. ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:9:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"拼多多(offer) ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:10:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230711 拼多多一面（过） 聊项目，30min 场景设计题：如何拉取频道成员，按照加入时间排序？zset 除了hash，为啥不用其他的数据结构？ 找到附近的人，怎么做？用什么redis 数据结构？Geo 对于redis的广度理解不够 函数延迟调用？ 一个整数数组，除了一个数，其他数都出现了两次，找出这个只出现一次的数： func findUniqueNum(nums []int) int{ res:=nums[0] for i:=1;i\u003clen(nums);i++{ res^=nums[i] } return res } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:10:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230716 拼多多二面（过） 万人大群抢红包怎么处理？读扩散+写扩散模式 kafka为什么快? Kafka 是一个高性能、可扩展的分布式消息队列系统，它之所以能够实现高吞吐量和低延迟，主要归功于以下几个设计原则和优化策略： 高效的磁盘存储和顺序读写：Kafka 将消息存储在磁盘上，并利用操作系统的 page cache 进行缓存。Kafka 的消息存储是顺序的，这意味着它可以充分利用磁盘的顺序读写性能。顺序读写比随机读写更快，因为磁盘的寻道时间得到了显著减少。 零拷贝技术：Kafka 使用了零拷贝技术（zero-copy）来减少数据在内核空间和用户空间之间的拷贝次数。这可以降低 CPU 使用率，减少上下文切换，从而提高性能。 批量处理：Kafka 支持批量发送和消费消息。生产者可以将多个消息打包成一个批次，一次性发送给 Kafka。同样，消费者也可以一次性从 Kafka 获取多个消息。批量处理可以减少网络开销和磁盘 I/O，从而提高吞吐量。 分区和多副本：Kafka 的主题可以分为多个分区，每个分区可以独立地存储和处理消息。这使得 Kafka 可以在多个服务器上并行处理消息，从而实现水平扩展。此外，Kafka 还支持多副本，可以提高数据的可靠性和可用性。 消息压缩：Kafka 支持对消息进行压缩，以减少网络传输和磁盘存储的开销。压缩可以降低 I/O 压力，提高吞吐量。 消费者组和消费者位移：Kafka 使用消费者组和消费者位移来实现高效的消息消费。消费者组可以实现负载均衡，多个消费者可以共同消费一个主题。消费者位移记录了消费者在每个分区中消费的位置，这使得消费者可以随时恢复消费进度，而无需查询 Kafka。 异步处理：Kafka 的生产者和消费者都支持异步处理。生产者可以在不等待服务器响应的情况下发送消息，消费者可以在不等待处理完成的情况下获取消息。异步处理可以降低延迟，提高吞吐量。 综上所述，Kafka 通过高效的磁盘存储、零拷贝技术、批量处理、分区和多副本、消息压缩、消费者组和消费者位移以及异步处理等设计原则和优化策略，实现了高吞吐量和低延迟的消息传输。 redis为什么这么快？ Redis 是一个高性能的键值存储系统，它之所以能够实现高速读写，主要归功于以下几个设计原则和优化策略： 内存存储：Redis 将所有数据存储在内存中，这意味着它可以避免磁盘 I/O 带来的性能开销。内存访问速度远远快于磁盘，因此 Redis 能够实现高速读写。 单线程模型：Redis 使用单线程模型处理客户端请求，这意味着它不需要处理多线程之间的同步和锁竞争问题。单线程模型简化了 Redis 的设计，降低了上下文切换和锁竞争带来的性能开销。 高效的数据结构：Redis 支持多种高效的数据结构，如字符串、列表、集合、哈希表和有序集合。这些数据结构在内存中的表示非常紧凑，且支持高效的操作。例如，Redis 的哈希表实现了自动扩容和收缩，以保持高效的内存使用和性能。 事件驱动模型：Redis 使用事件驱动模型处理网络 I/O，这使得它可以高效地处理大量并发连接。事件驱动模型避免了线程阻塞和上下文切换带来的性能开销。 管道化（Pipelining）：Redis 支持管道化，这意味着客户端可以一次性发送多个命令，而无需等待每个命令的响应。管道化可以降低网络延迟，提高吞吐量。 优化的内存管理：Redis 使用自定义的内存管理器和内存分配器，以减少内存碎片和提高内存使用效率。此外，Redis 还支持内存回收策略，如 LRU（最近最少使用）算法，以在内存不足时自动删除不常用的数据。 持久化策略：虽然 Redis 主要是内存存储，但它也支持持久化策略，如 RDB 快照和 AOF 日志。这些持久化策略可以在后台异步执行，以减少对性能的影响。 综上所述，Redis 通过内存存储、单线程模型、高效的数据结构、事件驱动模型、管道化、优化的内存管理和持久化策略等设计原则和优化策略，实现了高速读写。然而，这些优势也带来了一些限制，如内存容量限制和单线程处理能力限制。在实际应用中，需要根据具体需求权衡 Redis 的优势和限制 基于redis协议实现hbase协议？代理 写一个100%死锁的代码 func deadLock(){ var wg sync.WaitGroup wg.Add(2) ch1,ch2:=make(chan struct{},chan struct{}) go func(){ defer wg.Done() \u003c-ch1 ch2\u003c-struct{}{} }() go func(){ defer wg.Done() \u003c-ch2 ch1\u003c-struct{}{} }() wg.Wait() } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:10:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230723 拼多多三面（过） 聊项目，难点 为什么来上海，996扛得住吗？在腾讯目前看起来很好，时日尚短为啥跳槽 给定一个长度为n的数组nums，求前k（1\u003c=k\u003c=n）个元素的中位数，如果k是偶数，取中间两个数的平均数四舍五入，输出是一个长度为n的数组，result[k-1]代表nums前k个元素的中位数 // 时间复杂度：O(n^2*logn) // 空间复杂度：O(n) func getMid1(nums []int) []int { res := make([]int, len(nums)) for i := 0; i \u003c len(nums); i++ { tmp := make([]int, i+1) for j := 0; j \u003c len(tmp); j++ { tmp[j] = nums[j] } sort.Ints(tmp) if (i+1)\u00261 == 0 { sum := tmp[len(tmp)/2] + tmp[(len(tmp)-1)/2] mid := sum / 2 if sum%2 != 0 { mid += 1 } res[i] = mid } else { res[i] = tmp[len(tmp)/2] } } return res } // 时间复杂度：O(n^2) // 空间复杂度：O(1) func getMid2(nums []int) []int { res := make([]int, len(nums)) for i := 0; i \u003c len(nums); i++ { index := findBigger(nums, i, nums[i]) if index != -1 { tmp := nums[i] for j := i; j \u003e index; j-- { nums[j] = nums[j-1] } nums[index] = tmp } if (i+1)\u00261 == 0 { sum := nums[(i+1)/2] + nums[i/2] mid := sum / 2 if sum%2 != 0 { mid += 1 } res[i] = mid } else { res[i] = nums[i/2] } } return res } // 时间复杂度：O(log(n!)趋近于O(nlogn) // 空间复杂度：O(n) func getMid3(nums []int) []int { minH, maxH := newMinHeap(len(nums)), newMaxHeap(len(nums)) res := make([]int, len(nums)) for i := 0; i \u003c len(nums); i++ { if nums[i] \u003c minH.Peek() { maxH.Add(nums[i]) } else { minH.Add(nums[i]) } if maxH.Peek() \u003e minH.Peek() { tmp := maxH.Pop() maxH.Add(minH.Pop()) minH.Add(tmp) } if maxH.num \u003e minH.num+1 { minH.Add(maxH.Pop()) } if maxH.num \u003c minH.num { maxH.Add(minH.Pop()) } if (i+1)\u00261 == 0 { sum := maxH.Peek() + minH.Peek()+1 res[i] = sum / 2 } else { res[i] = maxH.Peek() } } return res } func findBigger(nums []int, n int, target int) int { if n == 0 || nums[n-1] \u003c= target { return -1 } i, j := 0, n-1 for i \u003c j { m := i + (j-i)/2 if nums[m] \u003e target { j = m } else { i = m + 1 } } return i } func (m *minHeap) Add(val int) { if m.num \u003c len(m.elements) { m.elements[m.num] = val } else { m.elements = append(m.elements, val) } m.num += 1 m.up(m.num - 1) } func (m *minHeap) Peek() int { if m.num == 0 { return math.MaxInt } return m.elements[0] } func (m *minHeap) Pop() int { if m.num == 0 { return math.MaxInt } val := m.elements[0] m.elements[0] = m.elements[m.num-1] m.num -= 1 m.down(0) return val } func (m *maxHeap) Add(val int) { if m.num \u003c len(m.elements) { m.elements[m.num] = val } else { m.elements = append(m.elements, val) } m.num += 1 m.up(m.num - 1) } func (m *maxHeap) Pop() int { if m.num == 0 { return math.MinInt } val := m.elements[0] m.elements[0] = m.elements[m.num-1] m.num -= 1 m.down(0) return val } func (m *maxHeap) Peek() int { if m.num == 0 { return math.MinInt } return m.elements[0] } func (m *maxHeap) up(index int) { for index \u003e 0 \u0026\u0026 m.elements[index] \u003e m.elements[(index-1)/2] { m.elements[index], m.elements[(index-1)/2] = m.elements[(index-1)/2], m.elements[index] index = (index - 1) / 2 } } func (m *maxHeap) down(index int) { for 2*index+1 \u003c m.num { j := 2*index + 1 if j+1 \u003c m.num \u0026\u0026 m.elements[j+1] \u003e m.elements[j] { j = j + 1 } if m.elements[index] \u003e= m.elements[j] { break } m.elements[index], m.elements[j] = m.elements[j], m.elements[index] index = j } } func (m *minHeap) up(index int) { for index \u003e 0 \u0026\u0026 m.elements[index] \u003c m.elements[(index-1)/2] { m.elements[index], m.elements[(index-1)/2] = m.elements[(index-1)/2], m.elements[index] index = (index - 1) / 2 } } func (m *minHeap) down(index int) { for 2*index+1 \u003c m.num { j := 2*index + 1 if j+1 \u003c m.num \u0026\u0026 m.elements[j+1] \u003c m.elements[j] { j = j + 1 } if m.elements[index] \u003c= m.elements[j] { break } m.elements[index], m.elements[j] = m.elements[j], m.elements[index] index = j } } func newMinHeap(n int) *minHeap { return \u0026minHeap{ elements: make([]int, n), num: 0, } } func newMaxHeap(n int) *maxHeap { return \u0026maxHeap{ elements: make([]int, n), num: 0, } } type minHeap struct { elements []int num int } type maxHeap struct { elements []int num int } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:10:3","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"最右 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:11:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230712 最右一面（挂） 场景设计题：有一个热榜帖子，每分钟,刷新10条帖子，最近24小时热度最高的100个帖子：使用redis的zet做延迟队列，时间戳作为score，存储任务，然后另外一个redis的zset存储这个 延迟队列具体怎么做？ --delayQueue: --key:hashTag+merge_messages --filed:guild_id:event_id:ip:hashTag --score:时间戳 --workQueue:带过期时间 --key:guild_id:event_id:ip:hashTag --filed:data（kafka数据） --score: 最后一个score local score = redis.call('ZSCORE', KEYS[1], KEYS[2]) if (score == false or score %% %d \u003e 0) then score = ARGV[1] redis.call('ZADD', KEYS[1], ARGV[1], KEYS[2]) end redis.call('ZADD', KEYS[2], score, ARGV[2]) return redis.call('EXPIRE', KEYS[2], ARGV[3]) ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:11:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"百度 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:12:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230713 百度一面（过） 表分裂的时候数据读写怎么办？表分裂比较低频，分裂过程大概100ms以内 对于其它技术了解的怎么样？ 合并n个有序链表，并对结果去重: type listNode struct{ val int next *listNode } func mergeListNodes(nodes []*listNode,l,r int) *listNode{ if l\u003er{ return ni } if l==r{ return nodes[l] } m:=l+(r-l)/2 h1,h2:=mergeListNodes(nodes,l,m),mergeListNodes(nodes,m+1,r) return merge(h1,h2) } func merge(h1,h2 *listNode){ if h1==nil{ return h2 } if h2==nil{ return h1 } var t *listNode if h1.val\u003ch2.val{ t=h1 h1=h1.next }else{ t=h2 h2=h2.next } p:=t for h1!=nil\u0026\u0026h2!=nil{ if h1.val\u003ch2.val{ if p.val!=h1.val{ p.next=h1 p=p.next } h1=h1.next }else{ if p.val!=h2.val{ p.next=h2 p=p.next } h2=h2.next } } for h1!=nil{ if p.val!=h1.val{ p.next=h1 p=p.next } h1=h1.next } for h2!=nil{ if p.val!=h2.val{ p.next=h2 p=p.next } h2=h2.next } return t } 第k个全排列： func kthPermutations(n int, k int) []int { res := make([]int, n) times, find := 0, false dfs(n, k, 0, res, make([]bool, n+1), \u0026times, \u0026find) return res } func dfs(n, k int, t int, res []int, visited []bool, times *int, find *bool) { if *find { return } if t == n { *times += 1 if *times == k { *find = true } return } for i := 1; i \u003c= n; i++ { if *find { return } if visited[i] { continue } visited[i] = true res[t] = i dfs(n, k, t+1, res, visited, times, find) visited[i] = false } } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:12:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230720 百度二面（过） 谈谈对go语言的理解，和java比较 go语言面向对象 go语言的并发、协程，底层原理 项目，项目架构、难点，抠细节。 一个二维有序数组，判断某个数是否在这个二维有序数组中 func findTarget(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } m, n := len(matrix), len(matrix[0]) i, j := 0, n-1 for i \u003c m \u0026\u0026 j \u003e= 0 { if matrix[i][j] == target { return true } if matrix[i][j] \u003e target { j-- } else { i++ } } return false } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:12:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"迅雷 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:13:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230714 迅雷一面（过） redis异地多活，多写同一个key方案？ MySQL分表原则。 为啥不能使用外键，外键的坑有哪些？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:13:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230718 迅雷二面（挂） 设计一个100亿级别的用户打卡系统，找出前排名前1w的用户 项目难点以及怎么解决的？ 对于未来的规划？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:13:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"滴滴 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:14:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230715 滴滴一面（过） Golang判空怎么判空，判空的坑？ new 和make的区别，内存分配怎么分配？new用于所有对象，make限制了slice、map、channel，new内存分配都在堆上，make有可能在栈上。 defer的作用域 切片和数组区别，函数传递是值传递还是引用传递？ 限流算法有哪些？怎么实现一个限流器？分布式限流器？ 本地限流器： package rateLimit import ( \"sync\" \"time\" ) // RateLimiter 限流接口 type RateLimiter interface { // Allow 是否运行本次请求 Allow() bool } // NewLeakyRater 漏桶算法限流实现 func NewLeakyRater(rate, capacity int64) RateLimiter { return \u0026leakyBucket{ rate: rate, capacity: capacity, lastLeakMs: time.Now().UnixNano() / 1e6, mu: \u0026sync.Mutex{}, } } // NewTokenRater 令牌桶算法限流实现 func NewTokenRater(rate, capacity int64) RateLimiter { return \u0026tokenBucket{ rate: rate, capacity: capacity, lastFillMs: time.Now().UnixNano() / 1e6, mu: \u0026sync.Mutex{}, } } type leakyBucket struct { rate int64 // 每s能够处理的请求个数 capacity int64 // 最多能够容纳的请求数量 water int64 // 当前处理的请求数量 lastLeakMs int64 // 上次泄漏的时间戳（毫秒） mu *sync.Mutex // 互斥锁，保证线程安全 } func (l *leakyBucket) Allow() bool { l.mu.Lock() // 加锁 defer l.mu.Unlock() // 函数结束时解锁 nowMs := time.Now().UnixNano() / 1e6 // 获取当前时间戳（毫秒） leakNum := (nowMs - l.lastLeakMs) * l.rate / 1000 // 计算从上次泄漏到现在泄漏的水量 l.water -= leakNum // 更新水量 l.lastLeakMs = nowMs // 更新上次泄漏时间 if l.water \u003c 0 { // 如果水量小于0，将水量设置为0 l.water = 0 } if l.water \u003c l.capacity { // 判断是否允许新的请求 l.water++ return true } return false } type tokenBucket struct { rate int64 // 令牌生成速率 capacity int64 // 令牌桶容量 tokens int64 // 当前令牌数量 lastFillMs int64 // 上次填充令牌的时间戳（毫秒） mu *sync.Mutex // 互斥锁，保证线程安全 } func (t *tokenBucket) Allow() bool { t.mu.Lock() // 加锁 defer t.mu.Unlock() // 函数结束时解锁 nowMs := time.Now().UnixNano() / 1e6 // 获取当前时间戳（毫秒） fillNum := (nowMs - t.lastFillMs) * t.rate / 1000 // 计算从上次填充到现在新增的令牌数量 t.tokens += fillNum // 更新令牌数量 t.lastFillMs = nowMs // 更新上次填充时间 if t.tokens \u003e t.capacity { // 如果令牌数量大于容量，将令牌数量设置为容量 t.tokens = t.capacity } if t.tokens \u003e 0 { // 判断是否允许新的请求 t.tokens-- return true } return false } 分布式限流器： -- 漏桶算法 -- leaky_bucket.lua local key = KEYS[1] -- Redis key local rate = tonumber(ARGV[1]) -- 漏桶处理速率 local capacity = tonumber(ARGV[2]) -- 漏桶容量 local now_ms = tonumber(ARGV[3]) -- 当前时间戳（毫秒） -- 从Redis中获取漏桶的当前水量和上次泄漏时间 local leaky_bucket = redis.call('HMGET', key, 'water', 'last_leak_ms') local water = tonumber(leaky_bucket[1]) local last_leak_ms = tonumber(leaky_bucket[2]) -- 计算从上次泄漏到现在泄漏的水量 local leak_num = math.floor((now_ms - last_leak_ms) * rate / 1000) water = water - leak_num last_leak_ms = now_ms -- 如果水量小于0，将水量设置为0 if water \u003c 0 then water = 0 end -- 判断是否允许新的请求 local allowed = 0 if water \u003c capacity then water = water + 1 allowed = 1 end -- 更新Redis中的漏桶状态 redis.call('HMSET', key, 'water', water, 'last_leak_ms', last_leak_ms) redis.call('EXPIRE', key, 2 * capacity / rate) return allowed -- 令牌桶算法 -- token_bucket.lua local key = KEYS[1] -- Redis key local rate = tonumber(ARGV[1]) -- 令牌生成速率 local capacity = tonumber(ARGV[2]) -- 令牌桶容量 local now_ms = tonumber(ARGV[3]) -- 当前时间戳（毫秒） -- 从Redis中获取令牌桶的当前令牌数量和上次填充时间 local token_bucket = redis.call('HMGET', key, 'tokens', 'last_fill_ms') local tokens = tonumber(token_bucket[1]) local last_fill_ms = tonumber(token_bucket[2]) -- 计算从上次填充到现在新增的令牌数量 local fill_num = math.floor((now_ms - last_fill_ms) * rate / 1000) tokens = tokens + fill_num last_fill_ms = now_ms -- 如果令牌数量大于容量，将令牌数量设置为容量 if tokens \u003e capacity then tokens = capacity end -- 判断是否允许新的请求 local allowed = 0 if tokens \u003e 0 then tokens = tokens - 1 allowed = 1 end -- 更新Redis中的令牌桶状态 redis.call('HMSET', key, 'tokens', tokens, 'last_fill_ms', last_fill_ms) redis.call('EXPIRE', key, 2 * capacity / rate) return allowed 全排列： // nums不重复，给出全排列 func dfs(nums []int,t int,tmp []int,visited []bool,res *[][]int){ if t==len(nums){ data:=make([]int,0,len(tmp)) for i:=0;i\u003clen(tmp);i++{ data=append(data,tmp[i]) } *res=append(*res,data) return } for i:=0;i\u003clen(nums);i++{ if visited[i]{ continue } tmp[t]=nums[i] visited[i]=true dfs(nums,t+1,visited,tmp,res) visited[i]=false } } 岛屿问题： func countGrid(grids [][]int)int{ res:=0 m,n:=len(grids),len(grids[0]) for i:=0;i\u003cm;i++{ for j:=0;j\u003cn;j++{ if grids[i][j]==1{ res++ gridDfs(grids,m","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:14:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230715 滴滴二面（挂） redis分布式锁的坑？锁过期，任务还没完成该怎么办？锁定时续期？ redis怎么实现一个可重入分布式锁？ redis的hash+lua脚本 加锁： -- key:hash的key，一般是业务的锁 -- expireTime: 过期时间 -- requestId:本次请求的唯一ID，可以理解为traceID，全局唯一 -- TryGetLock local function TryGetLock(key, requestId, expireTime) if redis.call('EXISTS', key) == 0 then -- 锁不存在，尝试获取锁 redis.call('HSET', key, requestId, 1) redis.call('PEXPIRE', key, expireTime) return 1, expireTime -- initialize else -- 锁存在，检查是否是同一个请求ID if redis.call('HEXISTS', key, requestId) == 1 then -- 是同一个请求ID，增加计数 redis.call('HINCRBY', key, requestId, 1) redis.call('PEXPIRE', key, expireTime) return 0, redis.call('PTTL', key) -- success else -- 不是同一个请求ID，获取锁失败 return -1, redis.call('PTTL', key) -- failed end end end 解锁： -- key:hash的key，一般是业务的锁 -- requestId:本次请求的唯一ID，可以理解为traceID，全局唯一 -- expireTime: 过期时间 -- TryUnLock local function TryUnLock(key, requestId, expireTime) if redis.call('EXISTS', key) == 0 then -- 锁不存在，释放锁成功 return 0, 0 -- success else -- 锁存在，检查是否是同一个请求ID if redis.call('HEXISTS', key, requestId) == 1 then local cnt = redis.call('HGET', key, requestId) if tonumber(cnt) == 1 then -- 计数为1，删除锁 redis.call('HDEL', key, requestId) return 0, 0 -- success else -- 是同一个请求ID，减少计数 redis.call('HINCRBY', key, requestId, -1) -- 给锁续期 redis.call('PEXPIRE', key, expireTime) return -1, redis.call('PTTL', key) -- failed end else -- 不是同一个请求ID，释放锁失败 return -1, redis.call('PTTL', key) -- failed end end end 怎么提供个分布式的redis对外使用？proxy、redis自适应hash、客户端hash 当MySQL表中某一列的类型是varchar，但是在sql语句中使用int查询，会有什么问题？性能下降、查询结果不准确，索引失效 1.在进行函数运算的时候，mysql会进行隐式转换，比如原始数据是varchar，varchar按照某种规则有序，转换成整数后可能排序规则就变了，就没法使用索引了，只能走全表扫描 2.函数运算本身也要时间的，这个会增加整体耗时。 3.函数转换的结果可能不准确，a123可能转成123，导致查询结果不准确 redis的cluster是怎么实现的？meet命令，分片集群，槽位。 varchar、char、text区别？如何选用哪种数据结构？varcha最大能存储的字符数，能全部存储数据吗？ char:定长字符串，性能更好，但可能会浪费存储空间 varchar :变长字符，最大存储字符长度是(1«16)-1,更节省空间，性能稍差。 text：文本，能够存储的长度最长，但是性能更差。 快照读和当前读，怎么实现快照读和当前读？多版本并发控制？ InnoDB存储引擎通过多版本并发控制（MVCC）实现了高并发性能和事务隔离。以下是InnoDB实现MVCC的具体细节： 事务版本号（Transaction ID）： InnoDB为每个事务分配一个唯一的递增的版本号，称为事务ID。事务ID用于标识事务的先后顺序，以及在MVCC中确定数据行的可见性。 Undo日志： InnoDB使用Undo日志来存储数据行的旧版本。当事务对数据行进行修改时，InnoDB会将修改前的数据行版本写入Undo日志。Undo日志分为两种：Insert Undo和Update Undo。Insert Undo用于存储新插入数据行的旧版本，Update Undo用于存储更新数据行的旧版本。 Read View： InnoDB为每个事务创建一个Read View，用于确定数据行的可见性。Read View包含以下信息： 事务的版本号（即快照版本号）。 当前活跃的事务列表（即在Read View创建时尚未提交的事务）。 Read View用于判断数据行的某个版本是否对当前事务可见。具体规则如下： 如果数据行的版本号小于等于Read View的版本号，并且不属于活跃事务列表，则该数据行对当前事务可见。 如果数据行的版本号大于Read View的版本号，或者属于活跃事务列表，则该数据行对当前事务不可见，需要查找其旧版本。 数据行结构： InnoDB的数据行包含以下与MVCC相关的系统列： DB_TRX_ID：表示最后修改数据行的事务ID。 DB_ROLL_PTR：表示指向数据行的上一个版本（即Undo日志）的指针。 数据行可见性判断： 当事务需要读取数据行时，InnoDB会根据Read View和数据行的系统列判断数据行的可见性。具体步骤如下： 检查数据行的DB_TRX_ID，如果小于等于Read View的版本号，并且不属于活跃事务列表，则该数据行对当前事务可见，可以直接返回。 如果数据行的DB_TRX_ID大于Read View的版本号，或者属于活跃事务列表，则该数据行对当前事务不可见，需要查找其旧版本。此时，通过DB_ROLL_PTR找到对应的Undo日志，并递归判断Undo日志中的数据行版本是否可见。 数据行修改： 当事务需要修改数据行时，InnoDB会执行以下操作： 为修改后的数据行分配一个新的事务ID（即当前事务的ID）。 将修改前的数据行版本写入Undo日志，并更新数据行的DB_ROLL_PTR指向Undo日志。 如果当前事务是第一个修改数据行的事务，还需要将数据行的DB_TRX_ID更新为当前事务的ID。 通过上述机制，InnoDB实现了MVCC，支持多个事务并发访问数据，同时保证了事务隔离性。需要注意的是，InnoDB的MVCC实现与事务隔离级别有关。在不同的隔离级别下，Read View的创建时机和数据行可见性判断规则可能会有所不同。 快照读和当前读 InnoDB通过在每个数据行中添加额外的系统列（如DB_TRX_ID和DB_ROLL_PTR）来维护数据的多个版本。 快照读（Snapshot Read）： 在InnoDB中，快照读主要用于实现可重复读（Repeatable Read）隔离级别。当事务开始时，InnoDB会为该事务分配一个唯一的事务ID，并记录当前的系统版本号作为快照版本号。 当事务需要读取数据时，InnoDB会遍历数据行的版本链表，找到版本号小于等于快照版本号的最新版本。具体步骤如下： 检查数据行的DB_TRX_ID，如果小于等于快照版本号，说明该行数据在事务开始前已经存在，可以直接返回。 如果数据行的DB_TRX_ID大于快照版本号，说明该行数据是在事务开始后被其他事务插入或更新的。此时，需要通过DB_ROLL_PTR找到该行数据的上一个版本。 递归检查上一个版本的DB_TRX_ID，直到找到一个版本号小于等于快照版本号的数据行，然后返回该行数据。 当前读（Current Read）： 在InnoDB中，当前读主要用于实现读已提交（Read Committed）隔离级别。当事务需要读取数据时，InnoDB会直接返回数据行的最新版本。具体步骤如下： 检查数据行的DB_TRX_ID，如果小于等于当前事务ID，说明该行数据在当前事务开始前已经存在，可以直接返回。 如果数据行的DB_TRX_ID大于当前事务ID，说明该行数据是在当前事务开始后被其他事务插入或更新的。此时，需要通过DB_ROLL_PTR找到该行数据的上一个版本。 递归检查上一个版本的DB_TRX_ID，直到找到一个版本号小于等于当前事务ID的数据行，然后返回该行数据。 需要注意的是，当前读可能导致不可重复读和幻读等问题。为了解决这些问题，InnoDB还提供了行锁和间隙锁等锁机制来实现更高的隔离级别。 cap理论，分区容错性必须得保证，可用性和一致性取舍，当为了高可用牺牲部分一致性的时候，有哪些手段可以尽量保证数据一致性？ 数据对账 读修复，自修复能力。 定时巡检，数据不一致上报。 异步消息队列，消费对账。 go语言判空的坑 两个协程交替打印0和1，","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:14:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"莉莉丝 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:15:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230721 莉莉丝一面（过） 聊项目难点 聚簇索引和非聚簇索引 redis的持久化方式？ redis挂了怎么办？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:15:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"小红书（HR挂） ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:16:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230727 小红书一面（过） mysql的事务，为什么用到事务？ java的jvm以及垃圾回收机制 java的hashmap和concurrent hashmap 项目难点，负责模块 mysql的索引，b+树 mysql的事务原子性怎么保证的？ 两个事务同时更新一条数据会发生什么？ 会阻塞，因为更新同一行数据自动使用排它锁 二叉树最大路径和 func getMaxPath(root *Tree) int{ if root==nil{ return 0 } result:=root.val postOrder(root,\u0026result) return result } func postOrder(root *Tree,result *int) int{ if root==nil{ return 0 } l,r:=postOrder(root.left,result),postOrder(root.right,result) mx:=max(l,r) mx=max(mx,l+r) mx=max(mx,0) *result=max(*result,mx+root.val) return max(max(l,r),0)+root.val } func max(a,b int) int{ if a\u003cb{ return b } return a } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:16:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230801 小红书二面（过） 项目大概30min 写一个线上可以使用的localCache，使用lru作为淘汰算法 package main import ( \"errors\" \"fmt\" \"hash/fnv\" \"log\" \"sync\" \"sync/atomic\" ) var ( errEmptyCache = errors.New(\"not initialization\") errInvalidKey = errors.New(\"invalid key\") errNotExist = errors.New(\"not existed key\") ) func main() { cache, err := NewLocalCache(5, 3) if err != nil { log.Fatalf(\"NewLocalCache failed:%+v\", err) } for i := 0; i \u003c 18; i++ { key := fmt.Sprintf(\"key%d\", i+1) val := []byte(fmt.Sprintf(\"val%d\", i+1)) if err = cache.Set(key, val); err != nil { log.Fatalf(\"set cache failed;key:%s,val:%s failed:%+v\", key, string(val), err) } } fmt.Println(*cache) fmt.Println(cache.totalKeyNum) cache.Iterator() if _, err = cache.Get(\"key3\"); err != nil { fmt.Println(err) } cache.Iterator() } type LocalCache struct { totalKeyNum int64 shards []*lru } func NewLocalCache(eachShardSize int, shardNum int) (*LocalCache, error) { if eachShardSize == 0 || shardNum == 0 { return nil, errEmptyCache } dataList := make([]*lru, shardNum) for i := 0; i \u003c len(dataList); i++ { dataList[i] = newLRU(eachShardSize) } return \u0026LocalCache{ shards: dataList, }, nil } func (l *LocalCache) Get(key string) ([]byte, error) { if len(key) == 0 { return nil, errInvalidKey } index := hash(key) % (len(l.shards)) l.shards[index].mu.Lock() defer l.shards[index].mu.Unlock() node, ok := l.shards[index].dict[key] if !ok { return nil, errNotExist } l.readPreheat(node, index) return node.val, nil } func (l *LocalCache) Set(key string, val []byte) error { if len(l.shards) == 0 { return errEmptyCache } if len(key) == 0 { return errInvalidKey } index := hash(key) % (len(l.shards)) l.shards[index].mu.Lock() defer l.shards[index].mu.Unlock() node, ok := l.shards[index].dict[key] if ok { node.val = val l.readPreheat(node, index) return nil } newNode := \u0026listNode{ val: val, next: l.shards[index].head.next, pre: l.shards[index].head, key: key, } l.shards[index].head.next.pre = newNode l.shards[index].head.next = newNode if l.shards[index].shardKeyNum == l.shards[index].size { deleteNode := l.shards[index].tail.pre l.shards[index].tail.pre = deleteNode.pre deleteNode.pre.next = l.shards[index].tail delete(l.shards[index].dict, deleteNode.key) atomic.AddInt64(\u0026l.totalKeyNum, -1) l.shards[index].shardKeyNum -= 1 } l.shards[index].dict[key] = newNode atomic.AddInt64(\u0026l.totalKeyNum, 1) l.shards[index].shardKeyNum += 1 return nil } func (l *LocalCache) Iterator() { for i := 0; i \u003c len(l.shards); i++ { fmt.Printf(\"shard%d begin\\n\", i+1) l.shards[i].iterator() fmt.Printf(\"shard%d end~ \\n \", i+1) fmt.Println() } } func (l *LocalCache) readPreheat(node *listNode, index int) { node.pre.next = node.next node.next.pre = node.pre node.next = l.shards[index].head.next l.shards[index].head.next.pre = node node.pre = l.shards[index].head l.shards[index].head.next = node } func (l *lru) iterator() { p := l.head for p.next != l.tail { p = p.next fmt.Printf(\"kev:%s,val:%s\\n\", p.key, p.val) } } func newLRU(eachShardSize int) *lru { head := \u0026listNode{} tail := \u0026listNode{} head.next = tail tail.pre = head return \u0026lru{ size: eachShardSize, head: head, tail: tail, mu: sync.Mutex{}, dict: make(map[string]*listNode, eachShardSize), } } type lru struct { mu sync.Mutex size int shardKeyNum int head, tail *listNode dict map[string]*listNode } type listNode struct { key string val []byte pre, next *listNode } func hash(key string) int { h := fnv.New32a() _, _ = h.Write([]byte(key)) return int(h.Sum32()) } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:16:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"29230808 小红书三面（过） 设计的这个分表hash结构具有通用性吗 为啥最初选用redis作为db使用 项目中有哪些不稳定的地方待解决，怎么解决？ 对未来的规划和期待 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:16:3","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"米哈游 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:17:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230801 米哈游一面（过） 项目30min 没有初始化的map和slice赋值会panic，recover能捕获吗？可以捕获 并发读写slice和map会panic吗？recover能捕获吗？会panic不能捕获 如果一个channel没有初始化，读写数据会有什么问题？读写不会阻塞，也不会panic 如果一个channel已经close，继续读写数据会有什么问题？如果panic能捕获异常吗？读不会有问题，写会panic且不能被捕获 子数组的最大乘积 func maxProduct1(nums []float64) float64 { if len(nums) == 0 { return 0 } dp1 := make([]float64, len(nums)) dp2 := make([]float64, len(nums)) dp1[1], dp2[1] = nums[0], nums[0] res := dp1[1] for i := 1; i \u003c len(nums); i++ { dp1[i] = max(nums[i], max(dp1[i-1]*nums[i], dp2[i-1]*nums[i])) dp2[i] = min(nums[i], min(dp1[i-1]*nums[i], dp2[i-1]*nums[i])) res = max(res, dp1[i]) } return res } func maxProduct2(nums []float64) float64 { if len(nums) == 0 { return 0 } dp1, dp2 := nums[0], nums[0] res := dp1 for i := 1; i \u003c len(nums); i++ { tmpDp1 := dp1 dp1 = max(nums[i], max(dp1*nums[i], dp2*nums[i])) dp2 = min(nums[i], min(tmpDp1*nums[i], dp2*nums[i])) res = max(res, dp1) } return res } func max(a, b float64) float64 { if a \u003c b { return b } return a } func min(a, b float64) float64 { if a \u003c b { return a } return b } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:17:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230808 米哈游二面（挂） 聊项目30min 消息流量怎么解决？消息的包体会很大 消息空洞怎么解决？ 消息的删除，只删除自己的消息多端同步？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:17:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"B站 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:18:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230802 B站一面（过） 主要聊项目，项目难点，表分裂 redis的cluster怎么实现的，如果扩容结点，redis该怎么做 redis的hash扩容该怎么做，是渐进式扩容吗？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:18:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230804 B站二面（过） 聊项目30min 怎么保证接口幂等 1.redis set nx 2.token机制+redis 3.关系型数据库+唯一索引 4.防重复表 5.分布式锁 快排 为啥用hash结构，其它结构不行吗？只用hash有啥问题？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:18:2","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230809 B站三面（过） 说一下你技术上最有成就感的一个事 非技术上最有成就感的一个事 长连接优势及好处 如果消息通道挂了，该怎么办？，有什么降级策略？ ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:18:3","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"鹰角 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:19:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230804 鹰角一面（挂） 项目，怎么分表，怎么拆分？ 如果要合并怎么办，子表空洞？子表合并？ 判断回文链表 package main import \"fmt\" func main() { h1 := buildListNode([]int{1, 2, 3, 4, 5}) // false h2 := buildListNode([]int{1, 2, 3, 2, 1}) // true h3 := buildListNode([]int{1, 2, 3, 3, 2, 5}) // false h4 := buildListNode([]int{1, 2, 3, 3, 2, 1}) // true h5 := buildListNode([]int{1, 2}) // false h6 := buildListNode([]int{1}) // true h7 := buildListNode([]int{1, 2, 2, 1}) // true h8 := buildListNode([]int{1, 1}) // true fmt.Println(isPalindrome(h1)) fmt.Println(isPalindrome(h2)) fmt.Println(isPalindrome(h3)) fmt.Println(isPalindrome(h4)) fmt.Println(isPalindrome(h5)) fmt.Println(isPalindrome(h6)) fmt.Println(isPalindrome(h7)) fmt.Println(isPalindrome(h8)) } func buildListNode(nums []int) *ListNode { h := \u0026ListNode{} p := h for _, num := range nums { p.Next = \u0026ListNode{Val: num} p = p.Next } return h.Next } func isPalindrome(head *ListNode) bool { if head == nil || head.Next == nil { return true } l1, l2 := findMedium(head) // head = reverse(head, l1) head = reverse1(head, l1) for l2 != nil \u0026\u0026 head != nil { if l2.Val != head.Val { return false } l2 = l2.Next head = head.Next } if l2 != nil || head != nil { return false } return true } func reverse1(begin, end *ListNode) *ListNode { if begin == nil || end == nil || begin == end { return begin } h := \u0026ListNode{} for begin != end { next := begin.Next begin.Next = h.Next h.Next = begin begin = next } end.Next = h.Next h.Next = end return h.Next } func reverse2(begin, end *ListNode) *ListNode { if begin == end { return begin } var p *ListNode for begin != end { next := begin.Next begin.Next = p p = begin begin = next } end.Next = p return end } func reverse3(begin *ListNode, end *ListNode) *ListNode { if begin == nil || begin == end { return begin } next := reverse1(begin.Next, end) begin.Next.Next = begin begin.Next = nil return next } func findMedium(head *ListNode) (*ListNode, *ListNode) { p := \u0026ListNode{ Next: head, } for head != nil \u0026\u0026 head.Next != nil { head = head.Next.Next p = p.Next } if head == nil { l2 := p.Next p.Next = nil return p, l2 } l2 := p.Next.Next p.Next = nil return p, l2 } type ListNode struct { Val int Next *ListNode } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:19:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"蚂蚁金服 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:20:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230814 蚂蚁金服一面（挂） 三数之和，无重复结果。 func threeSum(nums []int) [][]int { if len(nums) \u003c 3 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u003c len(nums)-2; i++ { if nums[i] \u003e 0 { break } if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } left, right := i+1, len(nums)-1 target := -nums[i] for left \u003c right { if nums[left]+nums[right] == target { res = append(res, []int{nums[i], nums[left], nums[right]}) l, r := nums[left], nums[right] for left \u003c right \u0026\u0026 nums[left] == l { left++ } for left \u003c right \u0026\u0026 nums[right] == r { right-- } } else if nums[left]+nums[right] \u003c target { left++ } else { right-- } } } return res } 单词数组反转，去掉多余空格 func reverseWords(words string) string { left, right := 0, len(words)-1 for left \u003c= right \u0026\u0026 !isLetter(words[left]) { left++ } for left \u003c= right \u0026\u0026 !isLetter(words[right]) { right-- } if left \u003e right { return \"\" } var sb strings.Builder words = reverseStr(words, left, right) i := 0 for i \u003c len(words) { j := i for j \u003c len(words) \u0026\u0026 isLetter(words[j]) { j++ } bs := reverseStr(words, i, j-1) sb.WriteString(bs) if j \u003c len(words) { sb.WriteString(\" \") } for j \u003c len(words) \u0026\u0026 words[j] == ' ' { j++ } i = j } return sb.String() } func reverseStr(s string, i, j int) string { if i \u003e j { return \"\" } res := []byte(s[i : j+1]) i, j = 0, len(res)-1 for i \u003c j { res[i], res[j] = res[j], res[i] i++ j-- } return string(res) } func isLetter(b byte) bool { return b != ' ' } 阻塞写入该怎么办，排队，聚合写入，异步。 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:20:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"字节跳动 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:21:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230821 字节跳动一面（挂） 聊项目，扣细节，底层关系链怎么设计，消息怎么分发。 一个好的系统应该是怎么样的？ 设计一个cache，带过期时间自动淘汰并且当数据满了的时候会使用lru算法淘汰内存 package main import ( \"fmt\" \"sync\" \"time\" ) // 国际化短视频 // tikto /** 设计一个对象cache, 他支持下列两个基本操作: set(id, object), 根据id设置对象; get(id): 根据id得到一个对象; 同时它有下面几个性质: 1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期; 2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数; 3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象; 请你设计这样一个cache; */ func main() { c := New(20, 10) c.Set(\"1\", 10) fmt.Println(c.Get(\"1\")) } type Cache struct { dict map[string]*listNode head, tail *listNode capacity int expireDuration int64 mu *sync.Mutex } func New(n int, x int64) Cache { head, tail := \u0026listNode{}, \u0026listNode{} head.right = tail tail.left = head cache := Cache{ dict: make(map[string]*listNode, n), head: head, tail: tail, capacity: n, expireDuration: x, mu: \u0026sync.Mutex{}, } go func() { for { time.Sleep(200 * time.Millisecond) cache.mu.Lock() const scanUmm = 100 i := 0 for k, v := range cache.dict { i++ if i == scanUmm { break } if v.expireTimeStamp \u003c int64(time.Now().Second()) { delete(cache.dict, k) v.left.right = v.right v.right.left = v.left } } cache.mu.Unlock() } }() return cache } func (c *Cache) Set(key string, val int) { c.mu.Lock() defer c.mu.Unlock() node, ok := c.dict[key] if ok { node.val = val node.expireTimeStamp = c.expireDuration + int64(time.Now().Second()) node.left.right = node.right node.right.left = node.left node.right = c.head.right c.head.right.left = node node.left = c.head c.head.right = node return } node = \u0026listNode{ key: key, val: val, expireTimeStamp: c.expireDuration + int64(time.Now().Second()), } if c.capacity == len(c.dict) { deletedNode := c.tail.left delete(c.dict, deletedNode.key) deletedNode.left.right = c.tail c.tail.left = deletedNode.left } c.dict[key] = node node.right = c.head.right c.head.right.left = node node.left = c.head c.head.right = node } func (c *Cache) Get(key string) int { c.mu.Lock() defer c.mu.Unlock() node, ok := c.dict[key] if !ok { return -10000 } if node.expireTimeStamp \u003c int64(time.Now().Second()) { delete(c.dict, node.key) node.left.right = node.right node.right.left = node.left return -10000 } node.expireTimeStamp = c.expireDuration + int64(time.Now().Second()) node.left.right = node.right node.right.left = node.left node.right = c.head.right c.head.right.left = node node.left = c.head c.head.right = node return node.val } type listNode struct { key string val int left, right *listNode expireTimeStamp int64 } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:21:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"百度 ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:22:0","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology","interview"],"content":"20230824 百度一面 聊项目，抠细节，30分钟 mysql的索引、事务 微服务治理手段，方法 连续子序列最大和 func maxSum(nums []int) int{ if len(nums)==0{ return 0 } s:=nums[0] res:=s for i:=1;i\u003clen(nums);i++{ s=max(nums[i],nums[i]+s) res=max(res,s) } return res } func max(a,b int) int{ if a\u003cb{ return b } return a } ","date":"2023-07-01","objectID":"https://www.bardblog.cn/interview/:22:1","tags":["MySQL","InnoDB","Redis","Kafka","Algorithm"],"title":"面试复盘","uri":"https://www.bardblog.cn/interview/"},{"categories":["technology"],"content":"介绍git的一些不太常见的高级用法","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"Git 子模块 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:0","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"概念 Git 子模块允许你将另一个 Git 仓库作为主仓库的子目录引入。每个子模块都是一个独立的 Git 项目，具有自己的提交、拉取和推送操作。主仓库以子模块的形式包含多个子仓库。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:1","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"示例 我们通过一个示例来了解如何使用 Git 子模块。 创建一个名为 “gitSubmodules” 的文件夹，并将其初始化为 Git 仓库： mkdir gitSubmodules cd gitSubmodules git init 添加一个远程 origin，并将仓库推送到 GitHub： git remote add origin git@github.com:你的用户名/gitSubmodules.git echo \"关于 gitSubmodules\" \u003e\u003e README.md git add . git commit -m \"初始化 gitSubmodules\" git push --set-upstream origin main 在这里，将 “你的用户名” 替换为你的 GitHub 用户名。 现在，让我们将两个子仓库添加到 “gitSubmodules” 仓库中： git submodule add git@github.com:你的用户名/submodule1.git git submodule add git@github.com:你的用户名/submodule2.git 执行这些命令后，“gitSubmodules” 仓库将添加子模块 “submodule1” 和 “submodule2”。此命令会将子模块的远程仓库克隆到 “gitSubmodules” 仓库的根目录中。 默认情况下，每个子模块将被放置在与子仓库同名的目录中。 如果你执行 git status 命令，你将看到仓库中现在有一个名为 “.gitmodules” 的文件，以及两个名为 “submodule1” 和 “submodule2” 的目录。 “.gitmodules” 文件存储了子模块的本地目录路径与远程仓库 URL 之间的映射关系。 提交并推送更改到主仓库： git add . git commit -m \"添加 submodule1 和 submodule2 子模块\" git push 这将把子模块的信息一并推送到远程仓库。 如果有人克隆了 “gitSubmodules” 仓库，他们最初会得到子模块的空目录。为了将子模块填充为其相应的内容，他们需要运行以下命令： git submodule init git submodule update 运行这些命令后，子模块的远程文件将与本地仓库同步，包括每个子模块的提交信息。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:2","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":["technology"],"content":"使用场景 Git 子模块在需要在主项目中引入其他项目时非常有用,每个项目可以拥有自己独立的仓库和版本控制历史，确保对主项目和子模块的修改互不干扰。 ","date":"2023-06-27","objectID":"https://www.bardblog.cn/git-advanced-usage/:1:3","tags":["git","linux"],"title":"Git高级用法","uri":"https://www.bardblog.cn/git-advanced-usage/"},{"categories":null,"content":"About Bard","date":"2023-06-24","objectID":"https://www.bardblog.cn/about/","tags":null,"title":"About Bard","uri":"https://www.bardblog.cn/about/"},{"categories":null,"content":"英文名：BardChen 地点：深圳 职业：程序员 运动：跑步、羽毛球、爬山 博客源码：https://github.com/YourFantasy/blog 博客理念：记录生活、记录成长。 ","date":"2023-06-24","objectID":"https://www.bardblog.cn/about/:0:0","tags":null,"title":"About Bard","uri":"https://www.bardblog.cn/about/"}]